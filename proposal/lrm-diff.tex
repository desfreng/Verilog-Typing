\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage[english]{babel}
\usepackage[mono=false]{libertine}

\usepackage{csquotes}
\usepackage{microtype}

\usepackage{parskip}
\usepackage{xcolor}

\usepackage{longtable}
\usepackage{booktabs}
\usepackage{array}

\usepackage{amsmath}

\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

\DeclareMathOperator{\Size}{L}

\newcommand{\tild}{\raisebox{-.7ex}{\textasciitilde{}}}

\newcommand{\binOp}{\texttt{+} \texttt{-} \texttt{*} \texttt{/} \texttt{\%}
\texttt{\&} \texttt{|} \texttt{\^{}} \texttt{\^{}\tild} \texttt{\tild\^{}}}
\newcommand{\unOp}{\texttt{+} \texttt{-} \texttt{\tild} \texttt{++}  \texttt{--}}
\newcommand{\shiftOp}{\texttt{>{}>} \texttt{<}\texttt{<} \texttt{**}
\texttt{>{}>{}>} \texttt{<}\texttt{<}\texttt{<}}
\newcommand{\compOp}{\texttt{===} \texttt{!==} \texttt{==?} \texttt{!=?}
  \texttt{==} \texttt{!=} \texttt{>} \texttt{>=} \texttt{<} \texttt{<=}}
\newcommand{\logicOp}{\texttt{\&\&} \texttt{||} \texttt{->} \texttt{<->}}
\newcommand{\redOp}{\texttt{\&} \texttt{\tild\&} \texttt{|} \texttt{\tild|}
\texttt{\^{}} \texttt{\tild\^{}} \texttt{\^{}\tild} \texttt{!}}

\title{Highlighted LRM Sections for Revision}
\author{Authors}
\date{}

\begin{document}
\maketitle

The following content consists of extracts taken directly from the latest
version of the official Language Reference Manual (LRM) of SystemVerilog
(IEEE 1800-2023). The sections containing text highlighted in
\textcolor{red}{red} represent the specific content we believe could be replaced
with our proposal, presented in the document
``Proposal for Improving Expression Size Determination in IEEE 1800 SystemVerilog''.

For clarity, the original LRM page number corresponding to the beginning of each
extracted section is included in that section's title (this page marker is
editorial and is not part of the original LRM text).

\begin{center}
\noindent\rule{.8\textwidth}{1pt}  
\end{center}

\renewcommand{\thesection}{11.4.\arabic{section}}
\setcounter{section}{3}

\section{Relational operators (p. 278)}

\textelp{}

When one or both operands of a relational expression are unsigned, the
expression shall be interpreted as a comparison between unsigned values.
  {
    \color{red}
    If the operands are of unequal bit lengths, the smaller operand
    shall be zero-extended to the size of the larger operand.
  }

When both operands are signed, the expression shall be interpreted as a
comparison between signed values.
  {
    \color{red}
    If the operands are of unequal bit
    lengths, the smaller operand shall be sign-extended to the size of the larger
    operand. See 11.8.2 for more information.
  }

If either operand is a real operand, then the other operand shall be converted to
an equivalent real value and the expression shall be interpreted as a comparison
between real values.

\textelp{}

\section{Equality operators (p. 279)}

\textelp{}

When one or both operands are unsigned, the expression shall be interpreted as a
comparison between unsigned values.
  {
    \color{red}
    If the operands are of unequal bit
    lengths, the smaller operand shall be zero-extended to the size of the larger
    operand.
  }

When both operands are signed, the expression shall be interpreted as a
comparison between signed values.
  {
    \color{red}
    If the operands are of unequal bit
    lengths, the smaller operand shall be sign-extended to the size of the larger
    operand. See 11.8.2 for more information.
  }

If either operand is a real operand, then the other operand shall be converted
to an equivalent real value, and the expression shall be interpreted as a
comparison between real values.

\textelp{}

\setcounter{section}{7}

\section{Bitwise operators (p. 281)}

\textelp{}

For the binary bitwise operators, if one or both operands are unsigned, the
result is unsigned.
  {
    \color{red}
    If the operands are of unequal bit lengths, the smaller
    operand shall be zero-extended to the size of the larger operand.
  }

If both operands are signed, the result is signed.
  {
    \color{red}
    If the operands are of
    unequal bit lengths, the smaller operand shall be sign-extended to the size of
    the larger operand. See 11.8.2 for more information.
  }

For the unary bitwise negation operator, if the operand is unsigned, the result
is unsigned. If the operand is signed, the result is signed.

\textelp{}

\renewcommand{\thesection}{11.6.\arabic{section}}
\setcounter{section}{0}

\section{Rules for expression bit lengths (p. 299)}

  {
    \color{red}

    The rules governing the expression bit lengths have been formulated so that most
    practical situations have a natural solution.

    The number of bits of an expression (known as the \emph{size} of the
    expression) shall be determined by the operands involved in the expression and
    the context in which the expression is given.

    A \emph{self-determined expression} is one where the bit length of the expression is
    solely determined by the expression itselfâ€”for example, an expression
    representing a delay value.

    A \emph{context-determined expression} is one where the bit length of the expression is
    determined by the bit length of the expression and by the fact that it is part
    of another expression. For example, the bit size of the right-hand expression of
    an assignment depends on itself and the size of the left-hand side.

    Table~11-21 shows how the form of an expression shall determine the bit lengths
    of the results of the expression. In Table~11-21, \texttt{i}, \texttt{j}, and
    \texttt{k} represent expressions of an operand, and \texttt{L(i)} represents the
    bit length of the operand represented by \texttt{i}.

    \begin{center}
      \textbf{Table 11-21---Bit lengths resulting from self-determined expressions}
      \begin{longtable}{|p{0.35\linewidth}|C{0.25\linewidth}|C{0.3\linewidth}|}
        \hline
        \centering \textbf{Expression}
         & \textbf{Bit length}
         & \textbf{Comments}
        \\
        \hline
        Unsized constant number
         & At least 32 bits
         &
        \\
        \hline
        Sized constant number
         & As given
         &
        \\
        \hline
        \verb|i op j|, where op is:

        \binOp{}
         & $\max\left(\Size(i), \Size(j)\right)$
         &
        \\
        \hline
        \verb|op i|, where op is:

        \unOp{}
         & $\Size(i)$
         &
        \\
        \hline
        \verb|i op j|, where op is:

        \compOp{}
         & 1 bit
         & Operands are sized to $\max\left(\Size(i), \Size(j)\right)$ \\
        \hline
        \verb|i op j|, where op is:

        \logicOp{}
         & 1 bit
         & All operands are self-determined
        \\
        \hline
        \verb|op i|, where op is:

        \redOp{}
         & 1 bit
         & All operands are self-determined
        \\
        \hline
        \verb|i op j|, where op is:

        \shiftOp{}
         & $\Size(i)$
         & j is self-determined
        \\
        \hline
        \verb|i ? j : k|
         & $\max\left(\Size(j), \Size(k)\right)$
         & i is self-determined
        \\
        \hline
        \verb|{i, ..., j}|
         & $\Size(i) + \dots + \Size(j)$
         & All operands are self-determined
        \\
        \hline
        \verb|{i {j, ..., k}}|
         & $i\times\left(\Size(i) + \dots + \Size(j)\right)$
         & All operands are self-determined
        \\
        \hline
      \end{longtable}
    \end{center}

    Multiplication may be performed without losing any overflow bits by assigning
    the result to something wide enough to hold it.
  }

\section{Example of expression bit-length problem (p. 300)}

\textelp{}

{
  \color{red}

  \section{Example of self-determined expressions (p. 301)}

  \begin{verbatim}
logic [3:0] a;
logic [5:0] b;
logic [15:0] c;
initial begin
   a = 4'hF;
   b = 6'hA;
   $display("a*b=%h", a*b);   // expression size is self-determined
   c = {a**b};                // expression a**b is self-determined
                              // due to concatenation operator {}
   $display("a**b=%h", c);
   c = a**b;                  // expression size is determined by c
   $display("c=%h", c);
end
\end{verbatim}

  Simulator output for this example:
  \begin{verbatim}
a*b=16   // 'h96 was truncated to 'h16 since expression size is 6
a**b=1   // expression size is 4 bits (size of a)
c=ac61   // expression size is 16 bits (size of c)
\end{verbatim}

}

\renewcommand{\thesection}{11.\arabic{section}}
\setcounter{section}{6}

\section{Signed expressions (p. 301)}

\textelp{}

\renewcommand{\thesection}{11.8.\arabic{section}}
\setcounter{section}{1}

\section{Steps for evaluating an expression (p. 302)}

  {
    \color{red}

    The following are the steps for evaluating an expression:
    \begin{itemize}
      \item Determine the expression size based upon the standard rules of
        expression size determination (see 11.6).
      \item Determine the sign of the expression using the rules outlined in
        11.8.1.
      \item Propagate the type and size of the expression (or self-determined
        subexpression) back down to the context-determined operands of the
        expression. In general, any context-determined operand of an operator
        shall be the same type and size as the result of the operator.
        However, there are two exceptions:
        \begin{itemize}
          \item If the result type of the operator is real and if it has a
            context-determined operand that is not real, that operand
            shall be treated as if it were self-determined and then
            converted to real just before the operator is applied.
          \item The relational and equality operators have operands that are
            neither fully self-determined nor fully context-determined. The
            operands shall affect each other as if they were context-determined
            operands with a result type and size (maximum of the two operand
            sizes) determined from them. However, the actual result type shall
            always be 1 bit unsigned. The type and size of the operand shall be
            independent of the rest of the expression and vice versa.
        \end{itemize}
      \item When propagation reaches a simple operand as defined in 11.5, then
        that operand shall be converted to the propagated type and size. If the
        operand shall be extended, then it shall be sign-extended only if the
        propagated type is signed.
    \end{itemize}

    \section{Steps for evaluating an assignment (p. 303)}

    The following are the steps for evaluating an assignment:
    \begin{itemize}
      \item Determine the size of the right-hand side by the standard assignment
        size determination rules (see 11.6).
      \item If needed, extend the size of the right-hand side, performing sign
        extension if, and only if, the type of the right-hand side is signed.
    \end{itemize}
  }

\section{Handling x and z in signed expressions (p. 303)}

\textelp{}

\end{document}
