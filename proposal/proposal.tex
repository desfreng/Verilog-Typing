\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage[english]{babel}
\usepackage[mono=false]{libertine}

\usepackage{microtype}
\usepackage{selnolig}

\usepackage[pdfencoding=auto]{hyperref}
\usepackage{bookmark}
\usepackage{parskip}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathabx}
\usepackage{xcolor}

\usepackage{minted}
\usepackage[boxruled]{algorithm2e}

\setminted{
  frame=lines,
  framesep=2mm,
  linenos=true,
  numbersep=5pt
}

\newcommand{\sv}[1]{\mintinline{verilog}{#1}}

\newcommand{\com}[1]{\textcolor{darkgray}{\tcp*[f]{#1}}}
\newcommand{\kw}[1]{\textnormal{\texttt{#1}}}

\SetKwSwitch{Switch}{Case}{Other}{switch}{do}{when}{otherwise}{}{}


\newcommand{\tild}{\raisebox{-.7ex}{\textasciitilde{}}}

\newcommand{\sds}{\emph{self-determined width}}
\newcommand{\mbr}{\emph{may be resized}}

\newenvironment{typingrule}[1]%
{\par\noindent\textbf{Rule (#1):} }%
{\par}

\newcommand{\binOp}{\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%},
\texttt{\&}, \texttt{|}, \texttt{\^{}}, \texttt{\^{}\tild},
\texttt{\tild\^{}}}
\newcommand{\unOp}{\texttt{+}, \texttt{-}, \texttt{\tild}, \texttt{++},
  \texttt{--}}
\newcommand{\shiftOp}{\texttt{>>}, \texttt{<}\texttt{<}, \texttt{**},
  \texttt{>>>}, \texttt{<}\texttt{<}\texttt{<}}
\newcommand{\compOp}{\texttt{===}, \texttt{!==}, \texttt{==?}, \texttt{!=?},
  \texttt{==}, \texttt{!=}, \texttt{>}, \texttt{>=}, \texttt{<}, \texttt{<=}}
\newcommand{\logicOp}{\texttt{\&\&}, \texttt{||}, \texttt{->}, \texttt{<->}}
\newcommand{\redOp}{\texttt{\&}, \texttt{\tild\&}, \texttt{|}, \texttt{\tild|},
\texttt{\^{}}, \texttt{\tild\^{}}, \texttt{\^{}\tild}, \texttt{!}}

\begin{document}

\section{Expression bit-widths}%
\label{expression-bit-widths}

The number of bits of any expression is determined by the operands and the
context in which it occurs. Casting can be used to set the target width of an
intermediate value (see 6.24).

Controlling the number of bits that are used in expression evaluations is
important if consistent results are to be achieved. The following typing system
provides precise rules for determining expression bit widths in all situations.

\subsection{Bidirectional typing operations}%

The bit width of expressions is defined using the fundamental concepts:

\begin{description}
  \item[Self-determined width]
    We call \sds{} the bit-width that is intrinsic to an expression: i.e.~it is
    solely based on the expression's internal structure and operands.

  \item[Resizing]
    Expressions \mbr{} to bit-widths greater than or equal to their \sds{}. This
    operation may change the width of the internal expression.
\end{description}

\subsection{Expression categories for resizing}%

SystemVerilog expressions shall be categorized into two types based on their
resizing behavior:

\subsubsection{Atomically resizable expressions}%

Atomically resizable expressions \mbr{} without affecting their
internal operand width. The following expressions are atomically resizable:

\begin{itemize}
  \item Operands as defined in 11.2 (nets, variables, literals, function
    calls, etc.)
  \item Comparison expressions: \compOp{}
  \item Logical expressions: \logicOp{}
  \item Reduction expressions: \redOp{}
  \item Assignment expressions: \texttt{=}
  \item Concatenation expressions: \texttt{\string{\dots\string}}
  \item Replication expressions: \texttt{\string{.\string{\dots\string}\string}}
  \item Set membership expressions: \texttt{inside}
\end{itemize}

When an atomically resizable expression is resized to a
target width, only the expression's result shall be extended --- its operands
shall remain unmodified.

\begin{typingrule}{Atomic-Resize}
  If $e$ has a \sds{} of $t$ and $n$ is larger than $t$
  and $e$ is atomically resizable, then $e$ \mbr{} to $n$.
\end{typingrule}

\subsubsection{Non-atomically resizable expressions}%

Non-atomically resizable expressions propagate resizing to their operands when
a target width is specified. These expressions require their operands to be
adjusted to specific widths based on the resizing rules. The following expression
are not atomically resizable:

\begin{itemize}
  \item Binary and bitwise expression: \binOp{}
  \item Unary arithmetic, bitwise, increment and decrement expressions:
    \unOp{}
  \item Shift and power expression: \shiftOp{}
  \item Conditional expression: \texttt{?:}
\end{itemize}

Binary arithmetic and bitwise expressions propagate the target width to both
operands:

\begin{typingrule}{Binary-Resize}
  If $a$ \mbr{} to $n$ and $b$ \mbr{} to $n$, then $a \oplus b$ \mbr{} to $n$.
\end{typingrule}

Unary arithmetic, unary bitwise negation and unary increment and decrement
expressions propagate the target width to their single operand:

\begin{typingrule}{Unary-Resize}
  If $e$ \mbr{} to $n$, then $\oplus e$ \mbr{} to $n$.
\end{typingrule}

Shift and power expressions propagate the target width only to the left operand,
while the right operand remains \emph{self-determined}:

\begin{typingrule}{Shift-Resize}
  If $a$ \mbr{} to $n$ and $b$ has a \sds{} of $t_{b}$, then
  $a \oplus b$ \mbr{} to $n$.
\end{typingrule}

Conditional expressions propagate the target width to both branch expressions,
while the condition remains \emph{self-determined}:

\begin{typingrule}{Conditional-Resize}
  If $c$ has a \sds{} width of $t_{C}$ and $t_{e}$ \mbr{} to $n$ and $f_{e}$
  \mbr{} to $n$, then $c~\texttt{?}~t_{e}~\texttt{:}~f_{e}$ \mbr{} to $n$.
\end{typingrule}

\subsection{\emph{Self-determined} expression sizing rules}%

The \sds{} of an expression, solely based on its internal
structure and operands, shall be computed according to the following rules:

\subsubsection{Operands}%

For operands as defined in 11.2, the \sds{} is always
well-defined and determined by their declaration, literal specification, or
result type:

\begin{typingrule}{Operand-Size}
  If $e$ is an operand and $s$ its width, then $e$ shall have a \sds{} of $s$.
\end{typingrule}

Examples:

\begin{itemize}
  \item Sized integer literals: \verb|8'hFF| has a \sds{} of 8,
    \verb|32'd123| has a \sds{} of 32,
  \item Unsized integer literals: \verb|123|, \verb|'hABC| have a
    \sds{} of at least 32 bits,
  \item Parameters, nets, variables and structure fields have their width
    defined by their declaration: \verb|logic [15:0] data| has a
    \sds{} of 16,
  \item Bit-select: \verb|data[5]| has a \sds{} of 1,
  \item Part-select: \verb|data[7:0]| has a \sds{} of 8,
    \verb|data[base +: 4]| has a \sds{} of 4,
  \item Function calls: Have their width defined by their return type --- a
    function returning \verb|logic [31:0]| has a
    \sds{} of 32,
  \item Variadic sized function calls: For functions whose return type depends
    on their arguments, the arguments' widths shall be determined as if
    they were in an assignment context. Once all argument widths are
    determined, the function's result type becomes known and defines the
    \sds{}.
\end{itemize}

\subsubsection{Binary arithmetic and bitwise expressions}%

For binary arithmetic and bitwise expressions, the \sds{}
is the maximum of the operand widths. The smaller operand is \emph{resized}
to match the larger operand's widths.

\begin{typingrule}{Binary-Left-Width}
  If $a$ has a \sds{} of $t$ and $b$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $t$.
\end{typingrule}

\begin{typingrule}{Binary-Right-Width}
  If $b$ has a \sds{} of $t$ and $a$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $t$.
\end{typingrule}

\subsubsection{Unary expressions}%

For unary expressions (Unary arithmetic, unary bitwise negation and unary
increment and decrement), the \sds{} is identical to the
operand width.

\begin{typingrule}{Unary-Width}
  If $e$ has a \sds{} of $t$, then $\oplus e$ shall have
  a \sds{} of $t$.
\end{typingrule}

\subsubsection{Relational and equality expressions}%

For relational and equality expressions, the \sds{} is
always 1 bit. The smaller operand shall be resized to match the larger operand's
width for comparison purposes.

\begin{typingrule}{Relational-Left-Width}
  If $a$ has a \sds{} of $t$ and $b$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $1$.
\end{typingrule}

\begin{typingrule}{Relational-Right-Width}
  If $b$ has a \sds{} of $t$ and $a$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $1$.
\end{typingrule}

\subsubsection{Logical expressions}%

For binary logical expressions, the \sds{} is always 1 bit.
All operands are \emph{self-determined}.

\begin{typingrule}{Logical-Width}
  If $a$ has a \sds{} of $t_{a}$ and $b$ has a
  \sds{} of $t_{b}$, then $a \oplus b$ shall have a
  \sds{} of 1.
\end{typingrule}

\subsubsection{Reduction expressions}%

For reduction expressions, including \texttt{!}, the \sds{}
is always 1 bit. The operand is \emph{self-determined}.

\begin{typingrule}{Reduction-Width}
  If $e$ has a \sds{} of $t$, then $\oplus e$ shall have a
  \sds{} of 1.
\end{typingrule}

\subsubsection{Shift and power expressions}%

For shift and power expressions, the \sds{} is determined
by the left operand. The right operand shall be \emph{self-determined}.

\begin{typingrule}{Shift-Width}
  If $a$ has a \sds{} of $t$ and $b$ has a
  \sds{} of $t_{b}$, then $a \oplus b$ shall have a
  \sds{} of $t$.
\end{typingrule}

\subsubsection{Assignment expressions}%

For assignment expressions, the \sds{} is determined by the
left-hand side. When the left-hand side has a larger width than the right-hand
side, the right-hand side shall \emph{be resized}. Otherwise, the right-hand
side shall be \emph{self-determined}.

\begin{typingrule}{Assignment-Left-Width}
  If the left-hand side $l$ has a width of $t$ and $e$ \mbr{} to
  $t$, then $l \oplus e$ shall have a \sds{} of $t$.
\end{typingrule}

\begin{typingrule}{Assignment-Right-Width}
  If the left-hand side $l$ has a width of $t$, $e$ has a
  \sds{} of $t_{e}$ and $t$ is smaller than $t_{e}$, then
  $l \oplus e$ shall have a \sds{} of $t$.
\end{typingrule}

\subsubsection{Conditional expressions}%

For conditional expressions using the \texttt{?:} operator, the
\sds{} is the maximum width of the two branch expressions.
The smaller branch shall be resized to match the larger branch. The condition
shall be \emph{self-determined}.

\begin{typingrule}{Conditional-Left-Width}
  If $c$ has a \sds{} of $t_{c}$, $a$ has a
  \sds{} of $t$, and $b$ \mbr{} to $t$,
  then $c \verb|?| a \verb|:| b$ shall have a \sds{} of
  $t$.
\end{typingrule}

\begin{typingrule}{Conditional-Right-Width}
  If $c$ has a \sds{} of $t_{c}$, $b$ has a
  \sds{} of $t$, and $a$ \mbr{} to $t$,
  then $c \verb|?| a \verb|:| b$ shall have a \sds{} of
  $t$.
\end{typingrule}

\subsubsection{Concatenation expressions}%

For concatenation expressions, the \sds{} is the sum of the
\emph{self-determined widths} of all operands.

\begin{typingrule}{Concatenation-Width}
  If $e_{1}$ has a \sds{} of $t_{1}$, \ldots, $e_{k}$ has a
  \sds{} of $t_{k}$, and $t$ is the sum of
  $t_{1}, \dots, t_{k}$, then $\verb|{|e_{1}, \dots, e_{k}\verb|}|$ shall have
  a \sds{} of $t$.
\end{typingrule}

\subsubsection{Replication expressions}%

The \sds{} of a replication is the
\sds{} of the inner concatenation multiplied by the
replication amount.

\begin{typingrule}{Replication-Width}
  If $i$ is the amount of the replication and $e_{in}$ has a
  \sds{} of $t_{in}$, and $t$ is $i \times t_{in}$, then
  $\verb|{| i \verb|{| e_{in}\verb|}}|$ shall have a
  \sds{} of $t$.
\end{typingrule}

\section{Examples}

Consider the following SystemVerilog declarations:

\begin{minted}{verilog}
logic [7:0] var8;      // 8-bit variable
logic [31:0] var32;    // 32-bit variable
logic [15:0] var16;    // 16-bit variable
logic cond;            // condition signal
logic [63:0] result;   // 64-bit result variable
\end{minted}

\subsection{Basic Expression Sizing}

In the previous context, the expression \sv{var8} has
\sds{} 8. Indeed, by rule \textbf{Operand-Width}:
\begin{itemize}
  \item \sv{var8} is an operand with width 8 (by declaration
    \sv{logic [7:0] var8})
\end{itemize}

In the previous context, the expression \sv{var16[15:8] + 4'b1001} has
\sds{} 8. Indeed, by rule \textbf{Binary-Left-Width}:

\begin{itemize}
  \item \sv{var16[15:8]} has \sds{} 8 (by rule
    \textbf{Operand-Width}, part-select of 8 bits)
  \item \sv{4'b1001} \mbr{} to 8 by rule \textbf{Resize}:
    \begin{itemize}
      \item \sv{4'b1001} has \sds{} 4 (by rule
        \textbf{Operand-Width}, sized integer literal)
      \item 8 is larger than 4
      \item \sv{4'b1001} is atomically resizable (operands are
        atomically resizable)
    \end{itemize}
\end{itemize}

If we tried to apply rule \textbf{Binary-Right-Width} on the previous expression
we would end up stuck resizing \sv{var16[15:8]} to 4 bits.

In the previous context, the expression \sv{var16[5] + 8'hFF} has
\sds{} 8. Indeed, by rule \textbf{Binary-Right-Width}:

\begin{itemize}
  \item \sv{8'hFF} has \sds{} 8 (by rule
    \textbf{Operand-Width}, sized integer literal)
  \item \sv{var16[5]} \mbr{} to 8 by rule \textbf{Resize}:
    \begin{itemize}
      \item \sv{var16[5]} has \sds{} 1 (by rule
        \textbf{Operand-Width}, bit-select)
      \item 8 is larger than 1
      \item \sv{var16[5]} is atomically resizable (operands are
        atomically resizable)
    \end{itemize}
\end{itemize}

\subsection{Relational Expression Example}

In the previous context, the expression \sv{var16 > 16'd100} has
\sds{} 1. Indeed, by rule \textbf{Relational-Left-Width}:

\begin{itemize}
  \item \sv{var16} has \sds{} 16 (by rule
    \textbf{Operand-Width}, declaration \sv{logic [15:0] var16})
  \item \sv{16'd100} \mbr{} to 16 --- this is actually not
    needed as it already has width 16:
    \begin{itemize}
      \item \sv{16'd100} has \sds{} 16 (by rule
        \textbf{Operand-Width}, sized integer literal)
    \end{itemize}
\end{itemize}

\subsection{Reduction Expression Example}

In the previous context, the expression \sv{&var16[7:0]} has
\sds{} 1. Indeed, by rule \textbf{Reduction-Width}:

\begin{itemize}
  \item \sv{var16[7:0]} has \sds{} 8 (by rule
    \textbf{Operand-Width}, part-select of 8 bits)
\end{itemize}

\subsection{Replication Expression Example}

In the previous context, the expression \sv{{4{var8}}} has
\sds{} 32. Indeed, by rule \textbf{Replication-Width}:

\begin{itemize}
  \item The replication amount $i$ is 4
  \item \sv{var8} has \sds{} 8 (by rule
    \textbf{Operand-Width}, declaration \sv{logic [7:0] var8})
  \item The result width is $4 \times 8 = 32$
\end{itemize}

\subsection{Complex Replication with Concatenation}

In the previous context, the expression \sv{{2{var16[7:0], 4'hF}}} has \sds{}
24. With rule \textbf{Replication-Width}:

\begin{itemize}
  \item The replication amount $i$ is 2
  \item The inner concatenation \sv{{var16[7:0], 4'hF}} has
    \sds{} 12 by rule \textbf{Concatenation-Width}:
    \begin{itemize}
      \item \sv{var16[7:0]} has \sds{} 8 (by rule
        \textbf{Operand-Width}, part-select)
      \item \sv{4'hF} has \sds{} 4 (by rule
        \textbf{Operand-Width}, sized literal)
      \item Sum is $8 + 4 = 12$
    \end{itemize}
  \item The result width is $2 \times 12 = 24$
\end{itemize}

\subsection{Assignment with Target Width Extension}

In the previous context, the expression \sv{var32 = var16[7:0] + 1} has
\sds{} 32. With rule \textbf{Assignment-Left-Width}:

\begin{itemize}
  \item Left-hand side \sv{var32} has width 32 (by declaration
    \sv{logic [31:0] var32})
  \item Right-hand side \sv{var16[7:0] + 1} \mbr{} to 32 by
    rule \textbf{Binary-Resize}:
    \begin{itemize}
      \item \sv{var16[7:0]} \mbr{} to 32 by rule
        \textbf{Resize}:
        \begin{itemize}
          \item \sv{var16[7:0]} has \sds{} 8
            (by rule \textbf{Operand-Width}, part-select)
          \item 32 is larger than 8
          \item \sv{var16[7:0]} is atomically resizable
            (operands are atomically resizable)
        \end{itemize}
      \item \sv{1} \mbr{} to 32 (unsized literals have
        \sds{} at least 32)
    \end{itemize}
\end{itemize}

\subsection{Assignment with Result Truncation}

In the previous context, the expression \sv{var8 = var32 + var16} has
\sds{} 8. Indeed, according to the rule \textbf{Assignment-Right-Width}:

\begin{itemize}
  \item Left-hand side \sv{var8} has width 8 (by declaration
    \sv{logic [7:0] var8})
  \item Right-hand side \sv{var32 + var16} has \sds{}
    32 by rule \textbf{Binary-Left-Width}:
    \begin{itemize}
      \item \sv{var32} has \sds{} 32 (by rule
        \textbf{Operand-Width}, declaration \sv{logic [31:0] var32})
      \item \sv{var16} \mbr{} to 32 by rule
        \textbf{Resize}:
        \begin{itemize}
          \item \sv{var16} has \sds{} 16 (by rule
            \textbf{Operand-Width}, declaration \sv{logic [15:0] var16})
          \item 32 is larger than 16
          \item \sv{var16} is atomically resizable (operands are atomically
            resizable)
        \end{itemize}
    \end{itemize}
  \item 8 is smaller than 32
\end{itemize}

\subsection{Conditional Expression with True Branch Determining Size}

In the previous context, the expression \sv{cond ? var32 : var8} has
\sds{} 32. Indeed, according to the rule \textbf{Conditional-Left-Width}:

\begin{itemize}
  \item Condition \sv{cond} has \sds{} 1 (by rule
    \textbf{Operand-Width}, declaration \sv{logic cond})
  \item True branch \sv{var32} has \sds{} 32 (by rule
    \textbf{Operand-Width}, declaration \sv{logic [31:0] var32})
  \item False branch \sv{var8} \mbr{} to 32 by rule
    \textbf{Resize}:
    \begin{itemize}
      \item \sv{var8} has \sds{} 8 (by rule
        \textbf{Operand-Width}, declaration \sv{logic [7:0] var8})
      \item 32 is larger than 8
      \item \sv{var8} is atomically resizable (operands are atomically
        resizable)
    \end{itemize}
\end{itemize}

\subsection{Conditional Expression with False Branch Determining Size}

In the previous context, the expression \sv{cond ? var8 : var32} has
\sds{} 32. Indeed, according to the rule \textbf{Conditional-Right-Width}:

\begin{itemize}
  \item Condition \sv{cond} has \sds{} 1 (by rule
    \textbf{Operand-Width}, declaration \sv{logic cond})
  \item False branch \sv{var32} has \sds{} 32 (by rule
    \textbf{Operand-Width}, declaration \sv{logic [31:0] var32})
  \item True branch \sv{var8} \mbr{} to 32 by rule
    \textbf{Resize}:
    \begin{itemize}
      \item \sv{var8} has \sds{} 8 (by rule
        \textbf{Operand-Width}, declaration \sv{logic [7:0] var8})
      \item 32 is larger than 8
      \item \sv{var8} is atomically resizable (operands are atomically
        resizable)
    \end{itemize}
\end{itemize}

\subsection{Conditional Expression with Context-Driven Sizing}

In the previous context, the expression
\sv{result = cond ? var32[7:0] : var32[15:8]} has \sds{}
64. Indeed, by rule \textbf{Assignment-Left-Width}:

\begin{itemize}
  \item Left-hand side \sv{result} has width 64 (by declaration
    \sv{logic [63:0] result})
  \item Right-hand side \sv{cond ? var32[7:0] : var32[15:8]}
    \mbr{} to 64 by rule \textbf{Conditional-Resize}:
    \begin{itemize}
      \item Condition \sv{cond} has \sds{} 1 (by rule
        \textbf{Operand-Width}, declaration \sv{logic cond})
      \item True branch \sv{var32[7:0]} \mbr{} to 64 by rule
        \textbf{Resize}:
        \begin{itemize}
          \item \sv{var32[7:0]} has \sds{} 8 (by rule
            \textbf{Operand-Width}, part-select)
          \item 64 is larger than 8
          \item \sv{var32[7:0]} is atomically resizable (operands are
            atomically resizable)
        \end{itemize}
      \item False branch \sv{var32[15:8]} \mbr{} to 64 by
        rule \textbf{Resize}:
        \begin{itemize}
          \item \sv{var32[15:8]} has \sds{} 8 (by rule
            \textbf{Operand-Width}, part-select)
          \item 64 is larger than 8
          \item \sv{var32[15:8]} is atomically resizable (operands are
            atomically resizable)
        \end{itemize}
    \end{itemize}
\end{itemize}

\appendix
\section{Algorithm Overview}

This appendix presents an algorithm to compute the width of all sub-expressions
of a SystemVerilog expression. The algorithm operates in two phases:

First, the \sds{} of the expression is computed using the algorithm
\ref{alg:determine}. This algorithm traverses the expression
tree bottom-up to determine the natural width of each expression based solely on
its internal structure and operands.

Second, the expression and all its sub-expressions are resized to the target
width using the algorithm \ref{alg:propagate}. During this
propagation phase, all self-determined sub-expressions are resized to their
\sds{}, while the other sub-expressions inherit their width from the surrounding
context.

Assuming that call to the \textsc{Determine} function are cached, the algorithm
runs in linear time with respect to the number of operations in
the SystemVerilog expression. The reasoning implemented in this algorithm
follows the typing rules explained in the previous
\autoref{expression-bit-widths}.

\newcommand\Determine[1]{\textsc{determine}(#1)}
\newcommand\Propagate[1]{\textsc{propagate}(#1)}

\begin{algorithm}
  \caption{Determine}
  \label{alg:determine}

  \SetKwData{Expr}{expr}
  \SetKwData{Lhs}{lhs}
  \SetKwData{LhsW}{lhs\textsubscript{w}}
  \SetKwData{Rhs}{rhs}
  \SetKwData{RhsW}{rhs\textsubscript{w}}
  \SetKwData{Arg}{arg}
  \SetKwData{ArgW}{arg\textsubscript{w}}
  \SetKwData{Lval}{lval}
  \SetKwData{LvalW}{lval\textsubscript{w}}
  \SetKwData{Cond}{cond}
  \SetKwData{CondW}{cond\textsubscript{w}}
  \SetKwData{ExprA}{expr\textsubscript{1}}
  \SetKwData{ExprN}{expr\textsubscript{N}}
  \SetKwData{ExprI}{expr\textsubscript{i}}
  \SetKwData{WidthI}{width\textsubscript{i}}

  \DontPrintSemicolon
  \SetAlgoVlined
  \LinesNumbered

  \KwIn{A SystemVerilog expression \Expr}
  \KwOut{The self-determined width of \Expr}
  \BlankLine
  \Switch{\Expr}{
    \Case{\Expr is an operand}{
      \Return{$\Gamma\left(\Expr\right)$}\;
    }
    \Case(\com{$\oplus$ can be \binOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      $\LhsW \leftarrow \Determine{\Lhs}$\;
      $\RhsW \leftarrow \Determine{\Rhs}$\;
      \Return{$\max\big(\LhsW, \RhsW\big)$}\;
    }
    \Case(\com{$\oplus$ can be \unOp{}}){\Expr is $\oplus\Arg$}{
      $\ArgW \leftarrow \Determine{\Arg}$\;
      \Return{\ArgW}\;
    }
    \Case(\com{$\oplus$ can be \compOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      \Return{$1$}\;
    }
    \Case(\com{$\oplus$ can be \logicOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      \Return{$1$}\;
    }
    \Case(\com{$\oplus$ can be \redOp{}}){\Expr is $\oplus\Arg$}{
      \Return{$1$}\;
    }
    \Case(\com{$\oplus$ can be \shiftOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      $\LhsW \leftarrow \Determine{\Lhs}$\;
      \Return{\LhsW}\;
    }
    \Case{\Expr is $\Lval\kw{~=~}\Rhs$}{
      $\LvalW \leftarrow \phi(\Lval)$\;
      \Return{\LvalW}\;
    }
    \Case{\Expr is $\Cond\kw{~?~}\Lhs\kw{~:~}\Rhs$}{
      $\LhsW \leftarrow \Determine{\Lhs}$\;
      $\RhsW \leftarrow \Determine{\Rhs}$\;
      \Return{$\max\left(\LhsW,\RhsW\right)$}\;
    }
    \Case{\Expr is $\kw{\{}\ExprA,\kw{~\dots~},\ExprN\kw{\}}$}{
      \For{$i \in \{1, \dots, N\}$}{
        $\WidthI \leftarrow \Determine{\ExprI}$\;
      }
      \Return{$\sum_{i=0}^{N}\WidthI$}\;
    }
    \Case{\Expr is $\kw{\{}n~\Arg\kw{\}}$}{
      $\ArgW \leftarrow \Determine{\Arg}$\;
      \Return{$n\times\ArgW$}\;
    }
  }
\end{algorithm}

\begin{algorithm}
  \caption{Propagate}
  \label{alg:propagate}

  \SetKwData{Expr}{expr}
  \SetKwData{TargetW}{targetWidth}
  \SetKwData{Lhs}{lhs}
  \SetKwData{LhsW}{lhs\textsubscript{w}}
  \SetKwData{Rhs}{rhs}
  \SetKwData{RhsW}{rhs\textsubscript{w}}
  \SetKwData{Arg}{arg}
  \SetKwData{ArgW}{arg\textsubscript{w}}
  \SetKwData{Lval}{lval}
  \SetKwData{LvalW}{lval\textsubscript{w}}
  \SetKwData{Cond}{cond}
  \SetKwData{CondW}{cond\textsubscript{w}}
  \SetKwData{ExprA}{expr\textsubscript{1}}
  \SetKwData{ExprN}{expr\textsubscript{N}}
  \SetKwData{ExprI}{expr\textsubscript{i}}
  \SetKwData{WidthI}{width\textsubscript{i}}

  \DontPrintSemicolon
  \SetAlgoVlined
  \LinesNumbered

  \KwIn{A SystemVerilog expression \Expr, A \TargetW to resize \Expr to.}
  \KwResult{All sub-expressions of \Expr are annotated with their final width}
  \Switch{\Expr}{
    \Case{\Expr is an operand}{
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \binOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      \Propagate{\Lhs, \TargetW}\;
      \Propagate{\Rhs, \TargetW}\;
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \unOp{}}){\Expr is $\oplus\Arg$}{
      \Propagate{\Arg, \TargetW}\;
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \compOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      $\ArgW \leftarrow \max\left(\Determine{\Lhs}, \Determine{\Rhs}\right)$\;
      \Propagate{\Lhs, \ArgW}\;
      \Propagate{\Rhs, \ArgW}\;
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \logicOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      \Propagate{\Lhs, \Determine{\Lhs}}\;
      \Propagate{\Rhs, \Determine{\Rhs}}\;
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \redOp{}}){\Expr is $\oplus\Arg$}{
      \Propagate{\Arg, \Determine{\Arg}}\;
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \shiftOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      \Propagate{\Lhs, \TargetW}\;
      \Propagate{\Rhs, \Determine{\Rhs}}\;
      Annotate \Expr with \TargetW\;
    }
    \Case{\Expr is $\Lval\kw{~=~}\Rhs$}{
      \Propagate{\Rhs, $\max\left(\phi(\Lval), \Determine{\Rhs}\right)$}\;
      Annotate \Expr with \TargetW\;
    }
    \Case{\Expr is $\Cond\kw{~?~}\Lhs\kw{~:~}\Rhs$}{
      \Propagate{\Cond, \Determine{\Cond}}\;
      \Propagate{\Lhs, \TargetW}\;
      \Propagate{\Rhs, \TargetW}\;
      Annotate \Expr with \TargetW\;
    }
    \Case{\Expr is $\kw{\{}\ExprA,\kw{~\dots~},\ExprN\kw{\}}$}{
      \For{$i \in \{1, \dots, N\}$}{
        \Propagate{\ExprI, \Determine{\ExprI}}\;
      }
      Annotate \Expr with \TargetW\;
    }
    \Case{\Expr is $\kw{\{}n~\Arg\kw{\}}$}{
      \Propagate{\Arg, \Determine{\Arg}}\;
      Annotate \Expr with \TargetW\;
    }
  }
\end{algorithm}

\end{document}
