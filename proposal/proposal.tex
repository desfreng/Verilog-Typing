\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage[english]{babel}
\usepackage[mono=false]{libertine}

\usepackage{microtype}
\usepackage{selnolig}

\usepackage[pdfencoding=auto]{hyperref}
\usepackage{bookmark}
\usepackage{parskip}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathabx}
\usepackage{cleveref}

\usepackage{xcolor}

\usepackage{minted}
\usepackage[boxruled]{algorithm2e}
\usepackage{csquotes}

\setminted{
  frame=lines,
  framesep=2mm,
  linenos=true,
  numbersep=5pt
}

\newcommand{\sv}[1]{\mintinline{verilog}{#1}}

\newcommand{\com}[1]{\textcolor{darkgray}{\tcp*[f]{#1}}}
\newcommand{\kw}[1]{\textnormal{\texttt{#1}}}

\SetKwSwitch{Switch}{Case}{Other}{switch}{do}{when}{otherwise}{}{}


\newcommand{\tild}{\raisebox{-.7ex}{\textasciitilde{}}}

\newcommand{\sds}{\emph{self-determined width}}
\newcommand{\mbr}{\emph{may be resized}}

\newenvironment{typingrule}[1]%
{\par\noindent\textbf{Rule (#1):} }%
{\par}

\newcommand{\binOp}{\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%},
\texttt{\&}, \texttt{|}, \texttt{\^{}}, \texttt{\^{}\tild},
\texttt{\tild\^{}}}
\newcommand{\unOp}{\texttt{+}, \texttt{-}, \texttt{\tild}, \texttt{++},
  \texttt{--}}
\newcommand{\shiftOp}{\texttt{>>}, \texttt{<}\texttt{<}, \texttt{**},
  \texttt{>>>}, \texttt{<}\texttt{<}\texttt{<}}
\newcommand{\compOp}{\texttt{===}, \texttt{!==}, \texttt{==?}, \texttt{!=?},
  \texttt{==}, \texttt{!=}, \texttt{>}, \texttt{>=}, \texttt{<}, \texttt{<=}}
\newcommand{\logicOp}{\texttt{\&\&}, \texttt{||}, \texttt{->}, \texttt{<->}}
\newcommand{\redOp}{\texttt{\&}, \texttt{\tild\&}, \texttt{|}, \texttt{\tild|},
\texttt{\^{}}, \texttt{\tild\^{}}, \texttt{\^{}\tild}, \texttt{!}}

\title{Proposal for Improving Expression Size Determination in IEEE 1800
SystemVerilog}
\author{Authors}
\date{}

\begin{document}
\maketitle

This document contains a proposal for inclusion in the current SystemVerilog
Language Reference Manual (LRM), IEEE 1800-2023, to clarify and formalize the
rules for determining expression bit-widths. It is designed to replace the
content highlighted in the document ``Highlighted LRM Sections for Revision.''

\begin{description}
  \item[\Crefrange{expression-bit-widths}{self-determined} (Expression bit-widths):]
    This material is proposed as replacement for the sub-sections in 11.6 of the
    current LRM. It introduces a revised formalization for bit-width
    determination, complete with rules governing this process, applicable to
    all SystemVerilog expressions. This content is a draft intended to
    replace existing content within the designated LRM section.

  \item[\Cref{examples} (Examples of bit-widths determination):]
    This section provides examples demonstrating the use of the bit-width
    determination rules defined in the preceding section. This content is
    proposed to extend the existing Section 11.6.3 of the LRM. The current
    version of the LRM offers a limited number of examples, primarily
    focusing on self-determined expressions. This draft proposes an update
    for this section, with the new bit-width determination mechanism and
    extensive examples for all kinds of SystemVerilog expressions.

  \item[\Cref{algorithm-overview} (Algorithmic Overview):]
    This content is proposed as a technical Appendix to the LRM. It formally
    describes the algorithms used to compute SystemVerilog expression
    bit-widths, which are only implicitly described in the current LRM
    version. This section also includes implementation considerations
    related to the efficient execution of the algorithms.
\end{description}

\begin{center}
  \noindent\rule{.8\textwidth}{1pt}
\end{center}

\renewcommand{\thesection}{11.6.\arabic{section}}
\setcounter{section}{0}

\section{Expression bit-widths}%
\label{expression-bit-widths}

The number of bits of any expression is determined by the operands and the
context in which it occurs. Casting can be used to set the target width of an
intermediate value (see 6.24).

Controlling the number of bits that are used in expression evaluations is
important if consistent results are to be achieved. The following typing system
provides precise rules for determining expression bit widths in all situations.

The bit width of expressions is defined using the fundamental concepts:

\begin{description}
  \item[Self-determined width]
    We call \sds{} the bit-width that is intrinsic to an expression: i.e.~it is
    solely based on the expression's internal structure and operands.

  \item[Resizing]
    Expressions \mbr{} to bit-widths greater than or equal to their \sds{}. This
    operation may change the width of the internal expression.
\end{description}

\section{Example of expression bit-length problem}%

\emph{Original sub-section of the LRM}
\textelp{}

\section{Expression categories for resizing}%

SystemVerilog expressions shall be categorized into two types based on their
resizing behavior:

\subsection{Atomically resizable expressions}%

Atomically resizable expressions \mbr{} without affecting their
internal operand width. The following expressions are atomically resizable:

\begin{itemize}
  \item Operands as defined in 11.2 (nets, variables, literals, function
    calls, etc.)
  \item Comparison expressions: \compOp{}
  \item Logical expressions: \logicOp{}
  \item Reduction expressions: \redOp{}
  \item Assignment expressions: \texttt{=}
  \item Concatenation expressions: \texttt{\string{\dots\string}}
  \item Replication expressions: \texttt{\string{.\string{\dots\string}\string}}
  \item Set membership expressions: \texttt{inside}
\end{itemize}

When an atomically resizable expression is resized to a
target width, only the expression's result shall be extended --- its operands
shall remain unmodified.

\begin{typingrule}{Atomic-Resize}
  If $e$ has a \sds{} of $t$ and $n$ is larger than $t$
  and $e$ is atomically resizable, then $e$ \mbr{} to $n$.
\end{typingrule}

\subsection{Non-atomically resizable expressions}%

Non-atomically resizable expressions propagate resizing to their operands when
a target width is specified. These expressions require their operands to be
adjusted to specific widths based on the resizing rules. The following expression
are not atomically resizable:

\begin{itemize}
  \item Binary and bitwise expression: \binOp{}
  \item Unary arithmetic, bitwise, increment and decrement expressions:
    \unOp{}
  \item Shift and power expression: \shiftOp{}
  \item Conditional expression: \texttt{?:}
\end{itemize}

Binary arithmetic and bitwise expressions propagate the target width to both
operands:

\begin{typingrule}{Binary-Resize}
  If $a$ \mbr{} to $n$ and $b$ \mbr{} to $n$, then $a \oplus b$ \mbr{} to $n$.
\end{typingrule}

Unary arithmetic, unary bitwise negation and unary increment and decrement
expressions propagate the target width to their single operand:

\begin{typingrule}{Unary-Resize}
  If $e$ \mbr{} to $n$, then $\oplus e$ \mbr{} to $n$.
\end{typingrule}

Shift and power expressions propagate the target width only to the left operand,
while the right operand remains \emph{self-determined}:

\begin{typingrule}{Shift-Resize}
  If $a$ \mbr{} to $n$ and $b$ has a \sds{} of $t_{b}$, then
  $a \oplus b$ \mbr{} to $n$.
\end{typingrule}

Conditional expressions propagate the target width to both branch expressions,
while the condition remains \emph{self-determined}:

\begin{typingrule}{Conditional-Resize}
  If $c$ has a \sds{} width of $t_{C}$ and $t_{e}$ \mbr{} to $n$ and $f_{e}$
  \mbr{} to $n$, then $c~\texttt{?}~t_{e}~\texttt{:}~f_{e}$ \mbr{} to $n$.
\end{typingrule}

\section{\emph{Self-determined} expression sizing rules}%
\label{self-determined}

The \sds{} of an expression, solely based on its internal
structure and operands, shall be computed according to the following rules:

\subsection{Operands}%

For operands as defined in 11.2, the \sds{} is always
well-defined and determined by their declaration, literal specification, or
result type:

\begin{typingrule}{Operand-Size}
  If $e$ is an operand and $s$ its width, then $e$ shall have a \sds{} of $s$.
\end{typingrule}

Examples:

\begin{itemize}
  \item Sized integer literals: \verb|8'hFF| has a \sds{} of 8,
    \verb|32'd123| has a \sds{} of 32,
  \item Unsized integer literals: \verb|123|, \verb|'hABC| have a
    \sds{} of at least 32 bits,
  \item Parameters, nets, variables and structure fields have their width
    defined by their declaration: \verb|logic [15:0] data| has a
    \sds{} of 16,
  \item Bit-select: \verb|data[5]| has a \sds{} of 1,
  \item Part-select: \verb|data[7:0]| has a \sds{} of 8,
    \verb|data[base +: 4]| has a \sds{} of 4,
  \item Function calls: Have their width defined by their return type --- a
    function returning \verb|logic [31:0]| has a
    \sds{} of 32,
  \item Variadic sized function calls: For functions whose return type depends
    on their arguments, the arguments' widths shall be determined as if
    they were in an assignment context. Once all argument widths are
    determined, the function's result type becomes known and defines the
    \sds{}.
\end{itemize}

\subsection{Binary arithmetic and bitwise expressions}%

For binary arithmetic and bitwise expressions, the \sds{}
is the maximum of the operand widths. The smaller operand is \emph{resized}
to match the larger operand's widths.

\begin{typingrule}{Binary-Left-Width}
  If $a$ has a \sds{} of $t$ and $b$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $t$.
\end{typingrule}

\begin{typingrule}{Binary-Right-Width}
  If $b$ has a \sds{} of $t$ and $a$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $t$.
\end{typingrule}

\subsection{Unary expressions}%

For unary expressions (Unary arithmetic, unary bitwise negation and unary
increment and decrement), the \sds{} is identical to the
operand width.

\begin{typingrule}{Unary-Width}
  If $e$ has a \sds{} of $t$, then $\oplus e$ shall have
  a \sds{} of $t$.
\end{typingrule}

\subsection{Relational and equality expressions}%

For relational and equality expressions, the \sds{} is
always 1 bit. The smaller operand shall be resized to match the larger operand's
width for comparison purposes.

\begin{typingrule}{Relational-Left-Width}
  If $a$ has a \sds{} of $t$ and $b$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $1$.
\end{typingrule}

\begin{typingrule}{Relational-Right-Width}
  If $b$ has a \sds{} of $t$ and $a$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $1$.
\end{typingrule}

\subsection{Logical expressions}%

For binary logical expressions, the \sds{} is always 1 bit.
All operands are \emph{self-determined}.

\begin{typingrule}{Logical-Width}
  If $a$ has a \sds{} of $t_{a}$ and $b$ has a
  \sds{} of $t_{b}$, then $a \oplus b$ shall have a
  \sds{} of 1.
\end{typingrule}

\subsection{Reduction expressions}%

For reduction expressions, including \texttt{!}, the \sds{}
is always 1 bit. The operand is \emph{self-determined}.

\begin{typingrule}{Reduction-Width}
  If $e$ has a \sds{} of $t$, then $\oplus e$ shall have a
  \sds{} of 1.
\end{typingrule}

\subsection{Shift and power expressions}%

For shift and power expressions, the \sds{} is determined
by the left operand. The right operand shall be \emph{self-determined}.

\begin{typingrule}{Shift-Width}
  If $a$ has a \sds{} of $t$ and $b$ has a
  \sds{} of $t_{b}$, then $a \oplus b$ shall have a
  \sds{} of $t$.
\end{typingrule}

\subsection{Assignment expressions}%

For assignment expressions, the \sds{} is determined by the
left-hand side. When the left-hand side has a larger width than the right-hand
side, the right-hand side shall \emph{be resized}. Otherwise, the right-hand
side shall be \emph{self-determined}.

\begin{typingrule}{Assignment-Left-Width}
  If the left-hand side $l$ has a width of $t$ and $e$ \mbr{} to
  $t$, then $l \oplus e$ shall have a \sds{} of $t$.
\end{typingrule}

\begin{typingrule}{Assignment-Right-Width}
  If the left-hand side $l$ has a width of $t$, $e$ has a
  \sds{} of $t_{e}$ and $t$ is smaller than $t_{e}$, then
  $l \oplus e$ shall have a \sds{} of $t$.
\end{typingrule}

\subsection{Conditional expressions}%

For conditional expressions using the \texttt{?:} operator, the
\sds{} is the maximum width of the two branch expressions.
The smaller branch shall be resized to match the larger branch. The condition
shall be \emph{self-determined}.

\begin{typingrule}{Conditional-Left-Width}
  If $c$ has a \sds{} of $t_{c}$, $a$ has a
  \sds{} of $t$, and $b$ \mbr{} to $t$,
  then $c \verb|?| a \verb|:| b$ shall have a \sds{} of
  $t$.
\end{typingrule}

\begin{typingrule}{Conditional-Right-Width}
  If $c$ has a \sds{} of $t_{c}$, $b$ has a
  \sds{} of $t$, and $a$ \mbr{} to $t$,
  then $c \verb|?| a \verb|:| b$ shall have a \sds{} of
  $t$.
\end{typingrule}

\subsection{Concatenation expressions}%

For concatenation expressions, the \sds{} is the sum of the
\emph{self-determined widths} of all operands.

\begin{typingrule}{Concatenation-Width}
  If $e_{1}$ has a \sds{} of $t_{1}$, \ldots, $e_{k}$ has a
  \sds{} of $t_{k}$, and $t$ is the sum of
  $t_{1}, \dots, t_{k}$, then $\verb|{|e_{1}, \dots, e_{k}\verb|}|$ shall have
  a \sds{} of $t$.
\end{typingrule}

\subsection{Replication expressions}%

The \sds{} of a replication is the
\sds{} of the inner concatenation multiplied by the
replication amount.

\begin{typingrule}{Replication-Width}
  If $i$ is the amount of the replication and $e_{in}$ has a
  \sds{} of $t_{in}$, and $t$ is $i \times t_{in}$, then
  $\verb|{| i \verb|{| e_{in}\verb|}}|$ shall have a
  \sds{} of $t$.
\end{typingrule}

\begin{center}
  \noindent\rule{.8\textwidth}{1pt}
\end{center}

\section{Examples of bit-widths determination}
\label{examples}

This section illustrates the application of sizing and type-derivation
rules as defined in this specification. The examples are derived from
the following declarations:

\begin{minted}{verilog}
logic [7:0]  var8;     // 8-bit variable
logic [31:0] var32;    // 32-bit variable
logic [15:0] var16;    // 16-bit variable
logic        cond;     // condition signal
logic [63:0] result;   // 64-bit result variable
\end{minted}

\subsection{Basic Expression Sizing}

This subsection demonstrates basic operand and binary expression
sizing behavior.

Given the above declarations, the expression \sv{var8} has \sds{} 8.
By application of rule \textbf{Operand-Width}:
\begin{itemize}
  \item \sv{var8} is an operand with width 8, as declared
    in \sv{logic [7:0] var8}.
\end{itemize}

The expression \sv{var16[15:8] + 4'b1001} has \sds{} 8.
By application of rule \textbf{Binary-Left-Width}:
\begin{itemize}
  \item \sv{var16[15:8]} has \sds{} 8 (by
    \textbf{Operand-Width}, part-select of 8 bits).
  \item \sv{4'b1001} \mbr{} to 8 by rule \textbf{Resize}:
    \begin{itemize}
      \item \sv{4'b1001} has \sds{} 4 (by
        \textbf{Operand-Width}, sized literal).
      \item 8 is greater than 4.
      \item \sv{4'b1001} is atomically resizable.
    \end{itemize}
\end{itemize}

Application of rule \textbf{Binary-Right-Width} to this expression
would not succeed, as it would require resizing \sv{var16[15:8]} to
4 bits.

The expression \sv{var16[5] + 8'hFF} has \sds{} 8. By rule
\textbf{Binary-Right-Width}:
\begin{itemize}
  \item \sv{8'hFF} has \sds{} 8 (by \textbf{Operand-Width},
    sized literal).
  \item \sv{var16[5]} \mbr{} to 8 by rule \textbf{Resize}:
    \begin{itemize}
      \item \sv{var16[5]} has \sds{} 1 (by
        \textbf{Operand-Width}, bit-select).
      \item 8 is greater than 1.
      \item \sv{var16[5]} is atomically resizable.
    \end{itemize}
\end{itemize}

\subsection{Relational Expression Example}

This subsection illustrates the determination of sizing for relational
expressions.

For the expression \sv{var16 > 16'd100}, the resulting \sds{} is 1.
By rule \textbf{Relational-Left-Width}:
\begin{itemize}
  \item \sv{var16} has \sds{} 16 (by \textbf{Operand-Width},
    declaration \sv{logic [15:0] var16}).
  \item \sv{16'd100} \mbr{} to 16 (already 16 bits):
    \begin{itemize}
      \item \sv{16'd100} has \sds{} 16 (by
        \textbf{Operand-Width}, sized literal).
    \end{itemize}
\end{itemize}

\subsection{Reduction Expression Example}

This subsection demonstrates sizing for reduction operations.

For the expression \sv{&var16[7:0]}, the resulting \sds{} is 1.
By rule \textbf{Reduction-Width}:
\begin{itemize}
  \item \sv{var16[7:0]} has \sds{} 8 (by
    \textbf{Operand-Width}, part-select of 8 bits).
\end{itemize}

\subsection{Replication Expression Example}

This subsection illustrates the effect of replication on expression
width.

For the expression \sv{{4{var8}}}, the resulting \sds{} is 32.
By rule \textbf{Replication-Width}:
\begin{itemize}
  \item The replication count $i$ is 4.
  \item \sv{var8} has \sds{} 8 (by \textbf{Operand-Width},
    declaration \sv{logic [7:0] var8}).
  \item The resulting width is $4 \times 8 = 32$.
\end{itemize}

\subsection{Complex Replication with Concatenation}

This subsection shows replication applied to a concatenated operand.

For the expression \sv{{2{var16[7:0], 4'hF}}}, the resulting
\sds{} is 24. By rule \textbf{Replication-Width}:
\begin{itemize}
  \item The replication count $i$ is 2.
  \item The inner concatenation \sv{{var16[7:0], 4'hF}} has
    \sds{} 12 by rule \textbf{Concatenation-Width}:
    \begin{itemize}
      \item \sv{var16[7:0]} has \sds{} 8 (by
        \textbf{Operand-Width}, part-select).
      \item \sv{4'hF} has \sds{} 4 (by
        \textbf{Operand-Width}, sized literal).
      \item Sum is $8 + 4 = 12$.
    \end{itemize}
  \item The resulting width is $2 \times 12 = 24$.
\end{itemize}

\subsection{Assignment with Target Width Extension}

This subsection illustrates extension of a right-hand operand to
match the assignment target.

For the expression \sv{var32 = var16[7:0] + 1}, the resulting
\sds{} is 32. By rule \textbf{Assignment-Left-Width}:
\begin{itemize}
  \item Left-hand side \sv{var32} has width 32
    (by declaration \sv{logic [31:0] var32}).
  \item Right-hand side \sv{var16[7:0] + 1} \mbr{} to 32
    by rule \textbf{Binary-Resize}:
    \begin{itemize}
      \item \sv{var16[7:0]} \mbr{} to 32 by rule \textbf{Resize}:
        \begin{itemize}
          \item \sv{var16[7:0]} has \sds{} 8 (by
            \textbf{Operand-Width}, part-select).
          \item 32 is greater than 8.
          \item \sv{var16[7:0]} is atomically resizable.
        \end{itemize}
      \item \sv{1} \mbr{} to 32 (unsized literals have
        at least 32 bits).
    \end{itemize}
\end{itemize}

\subsection{Assignment with Result Truncation}

This subsection shows truncation of the right-hand result to match
the left-hand target width.

For the expression \sv{var8 = var32 + var16}, the resulting
\sds{} is 8. By rule \textbf{Assignment-Right-Width}:
\begin{itemize}
  \item Left-hand side \sv{var8} has width 8 (by
    declaration \sv{logic [7:0] var8}).
  \item Right-hand side \sv{var32 + var16} has \sds{} 32
    (by \textbf{Binary-Left-Width}):
    \begin{itemize}
      \item \sv{var32} has \sds{} 32 (by
        \textbf{Operand-Width}, declaration
        \sv{logic [31:0] var32}).
      \item \sv{var16} \mbr{} to 32 by rule \textbf{Resize}:
        \begin{itemize}
          \item \sv{var16} has \sds{} 16 (by
            \textbf{Operand-Width}, declaration
            \sv{logic [15:0] var16}).
          \item 32 is greater than 16.
          \item \sv{var16} is atomically resizable.
        \end{itemize}
    \end{itemize}
  \item 8 is smaller than 32.
\end{itemize}

\subsection{Conditional Expression with True Branch Determining Size}

This subsection demonstrates conditional sizing where the true
branch determines the resulting width.

For the expression \sv{cond ? var32 : var8}, the resulting \sds{} is
32. By rule \textbf{Conditional-Left-Width}:
\begin{itemize}
  \item Condition \sv{cond} has \sds{} 1 (by
    \textbf{Operand-Width}, declaration \sv{logic cond}).
  \item True branch \sv{var32} has \sds{} 32 (by
    \textbf{Operand-Width}, declaration \sv{logic [31:0] var32}).
  \item False branch \sv{var8} \mbr{} to 32 by rule \textbf{Resize}:
    \begin{itemize}
      \item \sv{var8} has \sds{} 8 (by
        \textbf{Operand-Width}, declaration \sv{logic [7:0] var8}).
      \item 32 is greater than 8.
      \item \sv{var8} is atomically resizable.
    \end{itemize}
\end{itemize}

\subsection{Conditional Expression with False Branch Determining Size}

This subsection demonstrates conditional sizing where the false
branch determines the resulting width.

For the expression \sv{cond ? var8 : var32}, the resulting \sds{} is
32. By rule \textbf{Conditional-Right-Width}:
\begin{itemize}
  \item Condition \sv{cond} has \sds{} 1 (by
    \textbf{Operand-Width}, declaration \sv{logic cond}).
  \item False branch \sv{var32} has \sds{} 32 (by
    \textbf{Operand-Width}, declaration \sv{logic [31:0] var32}).
  \item True branch \sv{var8} \mbr{} to 32 by rule \textbf{Resize}:
    \begin{itemize}
      \item \sv{var8} has \sds{} 8 (by
        \textbf{Operand-Width}, declaration \sv{logic [7:0] var8}).
      \item 32 is greater than 8.
      \item \sv{var8} is atomically resizable.
    \end{itemize}
\end{itemize}

\subsection{Conditional Expression with Context-Driven Sizing}

This subsection demonstrates conditional sizing determined by the
context of an assignment target.

For the expression \sv{result = cond ? var32[7:0] : var32[15:8]}, the
resulting \sds{} is 64. By rule \textbf{Assignment-Left-Width}:
\begin{itemize}
  \item Left-hand side \sv{result} has width 64 (by
    declaration \sv{logic [63:0] result}).
  \item Right-hand side \sv{cond ? var32[7:0] : var32[15:8]}
    \mbr{} to 64 by rule \textbf{Conditional-Resize}:
    \begin{itemize}
      \item Condition \sv{cond} has \sds{} 1 (by
        \textbf{Operand-Width}, declaration \sv{logic cond}).
      \item True branch \sv{var32[7:0]} \mbr{} to 64 by
        \textbf{Resize}:
        \begin{itemize}
          \item \sv{var32[7:0]} has \sds{} 8 (by
            \textbf{Operand-Width}, part-select).
          \item 64 is greater than 8.
          \item \sv{var32[7:0]} is atomically resizable.
        \end{itemize}
      \item False branch \sv{var32[15:8]} \mbr{} to 64 by
        \textbf{Resize}:
        \begin{itemize}
          \item \sv{var32[15:8]} has \sds{} 8 (by
            \textbf{Operand-Width}, part-select).
          \item 64 is greater than 8.
          \item \sv{var32[15:8]} is atomically resizable.
        \end{itemize}
    \end{itemize}
\end{itemize}

\begin{center}
  \noindent\rule{.8\textwidth}{1pt}
\end{center}

\appendix
\section{Technical Appendix: Algorithm Overview}
\label{algorithm-overview}

This appendix presents an algorithm to compute the width of all sub-expressions
of a SystemVerilog expression. The algorithm operates in two phases:

First, the \sds{} of the expression is computed using the algorithm
\ref{alg:determine}. This algorithm traverses the expression
tree bottom-up to determine the natural width of each expression based solely on
its internal structure and operands.

Second, the expression and all its sub-expressions are resized to the target
width using the algorithm \ref{alg:propagate}. During this
propagation phase, all self-determined sub-expressions are resized to their
\sds{}, while the other sub-expressions inherit their width from the surrounding
context.

Assuming that call to the \textsc{Determine} function are cached, the algorithm
runs in linear time with respect to the number of operations in
the SystemVerilog expression. The reasoning implemented in this algorithm
follows the typing rules explained in the previous
\autoref{expression-bit-widths}.

\newcommand\Determine[1]{\textsc{determine}(#1)}
\newcommand\Propagate[1]{\textsc{propagate}(#1)}

\begin{algorithm}
  \caption{Determine}
  \label{alg:determine}

  \SetKwData{Expr}{expr}
  \SetKwData{Lhs}{lhs}
  \SetKwData{LhsW}{lhs\textsubscript{w}}
  \SetKwData{Rhs}{rhs}
  \SetKwData{RhsW}{rhs\textsubscript{w}}
  \SetKwData{Arg}{arg}
  \SetKwData{ArgW}{arg\textsubscript{w}}
  \SetKwData{Lval}{lval}
  \SetKwData{LvalW}{lval\textsubscript{w}}
  \SetKwData{Cond}{cond}
  \SetKwData{CondW}{cond\textsubscript{w}}
  \SetKwData{ExprA}{expr\textsubscript{1}}
  \SetKwData{ExprN}{expr\textsubscript{N}}
  \SetKwData{ExprI}{expr\textsubscript{i}}
  \SetKwData{WidthI}{width\textsubscript{i}}

  \DontPrintSemicolon
  \SetAlgoVlined
  \LinesNumbered

  \KwIn{A SystemVerilog expression \Expr}
  \KwOut{The self-determined width of \Expr}
  \BlankLine
  \Switch{\Expr}{
    \Case{\Expr is an operand}{
      \Return{$\Gamma\left(\Expr\right)$}\;
    }
    \Case(\com{$\oplus$ can be \binOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      $\LhsW \leftarrow \Determine{\Lhs}$\;
      $\RhsW \leftarrow \Determine{\Rhs}$\;
      \Return{$\max\big(\LhsW, \RhsW\big)$}\;
    }
    \Case(\com{$\oplus$ can be \unOp{}}){\Expr is $\oplus\Arg$}{
      $\ArgW \leftarrow \Determine{\Arg}$\;
      \Return{\ArgW}\;
    }
    \Case(\com{$\oplus$ can be \compOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      \Return{$1$}\;
    }
    \Case(\com{$\oplus$ can be \logicOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      \Return{$1$}\;
    }
    \Case(\com{$\oplus$ can be \redOp{}}){\Expr is $\oplus\Arg$}{
      \Return{$1$}\;
    }
    \Case(\com{$\oplus$ can be \shiftOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      $\LhsW \leftarrow \Determine{\Lhs}$\;
      \Return{\LhsW}\;
    }
    \Case{\Expr is $\Lval\kw{~=~}\Rhs$}{
      $\LvalW \leftarrow \phi(\Lval)$\;
      \Return{\LvalW}\;
    }
    \Case{\Expr is $\Cond\kw{~?~}\Lhs\kw{~:~}\Rhs$}{
      $\LhsW \leftarrow \Determine{\Lhs}$\;
      $\RhsW \leftarrow \Determine{\Rhs}$\;
      \Return{$\max\left(\LhsW,\RhsW\right)$}\;
    }
    \Case{\Expr is $\kw{\{}\ExprA,\kw{~\dots~},\ExprN\kw{\}}$}{
      \For{$i \in \{1, \dots, N\}$}{
        $\WidthI \leftarrow \Determine{\ExprI}$\;
      }
      \Return{$\sum_{i=0}^{N}\WidthI$}\;
    }
    \Case{\Expr is $\kw{\{}n~\Arg\kw{\}}$}{
      $\ArgW \leftarrow \Determine{\Arg}$\;
      \Return{$n\times\ArgW$}\;
    }
  }
\end{algorithm}

\begin{algorithm}
  \caption{Propagate}
  \label{alg:propagate}

  \SetKwData{Expr}{expr}
  \SetKwData{TargetW}{targetWidth}
  \SetKwData{Lhs}{lhs}
  \SetKwData{LhsW}{lhs\textsubscript{w}}
  \SetKwData{Rhs}{rhs}
  \SetKwData{RhsW}{rhs\textsubscript{w}}
  \SetKwData{Arg}{arg}
  \SetKwData{ArgW}{arg\textsubscript{w}}
  \SetKwData{Lval}{lval}
  \SetKwData{LvalW}{lval\textsubscript{w}}
  \SetKwData{Cond}{cond}
  \SetKwData{CondW}{cond\textsubscript{w}}
  \SetKwData{ExprA}{expr\textsubscript{1}}
  \SetKwData{ExprN}{expr\textsubscript{N}}
  \SetKwData{ExprI}{expr\textsubscript{i}}
  \SetKwData{WidthI}{width\textsubscript{i}}

  \DontPrintSemicolon
  \SetAlgoVlined
  \LinesNumbered

  \KwIn{A SystemVerilog expression \Expr, A \TargetW to resize \Expr to.}
  \KwResult{All sub-expressions of \Expr are annotated with their final width}
  \Switch{\Expr}{
    \Case{\Expr is an operand}{
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \binOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      \Propagate{\Lhs, \TargetW}\;
      \Propagate{\Rhs, \TargetW}\;
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \unOp{}}){\Expr is $\oplus\Arg$}{
      \Propagate{\Arg, \TargetW}\;
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \compOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      $\ArgW \leftarrow \max\left(\Determine{\Lhs}, \Determine{\Rhs}\right)$\;
      \Propagate{\Lhs, \ArgW}\;
      \Propagate{\Rhs, \ArgW}\;
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \logicOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      \Propagate{\Lhs, \Determine{\Lhs}}\;
      \Propagate{\Rhs, \Determine{\Rhs}}\;
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \redOp{}}){\Expr is $\oplus\Arg$}{
      \Propagate{\Arg, \Determine{\Arg}}\;
      Annotate \Expr with \TargetW\;
    }
    \Case(\com{$\oplus$ can be \shiftOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
      \Propagate{\Lhs, \TargetW}\;
      \Propagate{\Rhs, \Determine{\Rhs}}\;
      Annotate \Expr with \TargetW\;
    }
    \Case{\Expr is $\Lval\kw{~=~}\Rhs$}{
      \Propagate{\Rhs, $\max\left(\phi(\Lval), \Determine{\Rhs}\right)$}\;
      Annotate \Expr with \TargetW\;
    }
    \Case{\Expr is $\Cond\kw{~?~}\Lhs\kw{~:~}\Rhs$}{
      \Propagate{\Cond, \Determine{\Cond}}\;
      \Propagate{\Lhs, \TargetW}\;
      \Propagate{\Rhs, \TargetW}\;
      Annotate \Expr with \TargetW\;
    }
    \Case{\Expr is $\kw{\{}\ExprA,\kw{~\dots~},\ExprN\kw{\}}$}{
      \For{$i \in \{1, \dots, N\}$}{
        \Propagate{\ExprI, \Determine{\ExprI}}\;
      }
      Annotate \Expr with \TargetW\;
    }
    \Case{\Expr is $\kw{\{}n~\Arg\kw{\}}$}{
      \Propagate{\Arg, \Determine{\Arg}}\;
      Annotate \Expr with \TargetW\;
    }
  }
\end{algorithm}

\end{document}
