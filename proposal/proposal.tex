\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage[english]{babel}
\usepackage[mono=false]{libertine}

\usepackage{microtype}
\usepackage{selnolig}

\usepackage[pdfencoding=auto]{hyperref}
\usepackage{bookmark}
\usepackage{parskip}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathabx}
\usepackage{cleveref}

\usepackage{xcolor}

\usepackage{longtable}
\usepackage{booktabs}
\usepackage{array}

\usepackage{cite}

\usepackage{minted}
\usepackage[boxruled]{algorithm2e}
\usepackage{csquotes}
\usepackage[most]{tcolorbox}

\newcommand{\lrm}[2]{\cite[\S #1, p. #2]{IEEE1800}}

\NewDocumentEnvironment{lrmquote}{m m}{%
  \setlength\topsep{1pt}
  \setlength\parskip{0pt}
  \begin{center}
  \begin{minipage}{\textwidth}
  \begin{tcolorbox}[
    empty,
    colback=white,
    sharp corners,
    borderline west={2.5pt}{0pt}{black!20},
    before skip=0pt,
    after skip=0pt,
    left=5pt,
    right=5pt,
    top=10pt,
    bottom=10pt
  ]
}{%
  \nobreak\hfill\lrm{#1}{#2}
  \end{tcolorbox}
  \end{minipage}
  \end{center}
}

\setminted{
  frame=lines,
  framesep=2mm,
  linenos=true,
  numbersep=5pt
}

\definecolor{darkred}{RGB}{175, 0, 0}
\definecolor{darkgreen}{RGB}{20, 100, 20}

\newcommand{\del}{\color{darkred}}
\newcommand{\add}{\color{darkgreen}}

\newcommand{\sv}[1]{{\color{black}\mintinline{verilog}{#1}}}

\newcommand{\com}[1]{\textcolor{darkgray}{\tcp*[f]{#1}}}
\newcommand{\kw}[1]{\textnormal{\texttt{#1}}}

\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

\DeclareMathOperator{\Size}{L}

\SetKwSwitch{Switch}{Case}{Other}{switch}{do}{when}{otherwise}{}{}


\newcommand{\tild}{\raisebox{-.7ex}{\textasciitilde{}}}

\newcommand{\sds}{\emph{self-determined width}}
\newcommand{\mbr}{\emph{may be resized}}

\newenvironment{typingrule}[1]%
{\par\noindent\textbf{Rule (#1):} }%
{\par}

\newcommand{\binOp}{\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%},
\texttt{\&}, \texttt{|}, \texttt{\^{}}, \texttt{\^{}\tild},
\texttt{\tild\^{}}}
\newcommand{\unOp}{\texttt{+}, \texttt{-}, \texttt{\tild}, \texttt{++},
  \texttt{-{}-}}
\newcommand{\shiftOp}{\texttt{>{}>}, \texttt{<}\texttt{<}, \texttt{**},
  \texttt{>{}>{}>}, \texttt{<}\texttt{<}\texttt{<}}
\newcommand{\compOp}{\texttt{===}, \texttt{!==}, \texttt{==?}, \texttt{!=?},
  \texttt{==}, \texttt{!=}, \texttt{>}, \texttt{>=}, \texttt{<}, \texttt{<=}}
\newcommand{\logicOp}{\texttt{\&\&}, \texttt{||}, \texttt{->}, \texttt{<->}}
\newcommand{\redOp}{\texttt{\&}, \texttt{\tild\&}, \texttt{|}, \texttt{\tild|},
\texttt{\^{}}, \texttt{\tild\^{}}, \texttt{\^{}\tild}, \texttt{!}}

\title{Proposal for Improving Expression Size Determination in IEEE 1800
  SystemVerilog}
\author{Authors}
\date{}

\begin{document}
\maketitle

This document contains a proposal for inclusion in the current SystemVerilog
Language Reference Manual (LRM), IEEE 1800-2023, to clarify and formalize the
rules for determining expression bit-widths.

Paragraphs with a gray border on the left are extracts taken directly from the
latest version of the LRM. The sections containing text highlighted in
  {\del{}red} represent the specific content we believe could be replaced
with our proposal. Our propositions, in {\add green}, are organized as follows:

\begin{description}
  \item[\Crefrange{expression-bit-widths}{self-determined} (Expression bit-widths):]
    This material introduces a revised formalization for bit-width
    determination, complete with rules governing this process, applicable to
    all SystemVerilog expressions.

  \item[\Cref{examples} (Examples of bit-widths determination):]
    This section provides examples demonstrating the use of the bit-width
    determination rules defined in the preceding section. The current
    version of the LRM offers a limited number of examples, primarily
    focusing on self-determined expressions. This draft proposes an update
    to this section, incorporating the new bit-width determination mechanism
    and extensive examples for all kinds of SystemVerilog expressions.

  \item[\Cref{algorithm-overview} (Algorithmic Overview):]
    This content is proposed as a technical Appendix to the LRM. It formally
    describes the algorithms used to compute SystemVerilog expression
    bit-widths, which are only implicitly described in the current LRM
    version. This section also includes implementation considerations
    related to the efficient execution of the algorithms.
\end{description}

\begin{center}
  \noindent\rule{.8\textwidth}{1pt}
\end{center}

\renewcommand{\thesection}{11.4.\arabic{section}}
\setcounter{section}{3}

\begin{lrmquote}{11.4.4}{278}
  \section{Relational operators}

  \textelp{}

  When one or both operands of a relational expression are unsigned, the
  expression shall be interpreted as a comparison between unsigned values.
    {
      \del
      If the operands are of unequal bit lengths, the smaller operand
      shall be zero-extended to the size of the larger operand.
    }

  When both operands are signed, the expression shall be interpreted as a
  comparison between signed values.
    {
      \del{}
      If the operands are of unequal bit
      lengths, the smaller operand shall be sign-extended to the size of the larger
      operand. See 11.8.2 for more information.
    }

  If either operand is a real operand, then the other operand shall be converted to
  an equivalent real value and the expression shall be interpreted as a comparison
  between real values.

  \textelp{}
\end{lrmquote}

\begin{lrmquote}{11.4.5}{279}
  \section{Equality operators}

  \textelp{}

  When one or both operands are unsigned, the expression shall be interpreted as a
  comparison between unsigned values.
    {
      \del{}
      If the operands are of unequal bit
      lengths, the smaller operand shall be zero-extended to the size of the larger
      operand.
    }

  When both operands are signed, the expression shall be interpreted as a
  comparison between signed values.
    {
      \del{}
      If the operands are of unequal bit
      lengths, the smaller operand shall be sign-extended to the size of the larger
      operand. See 11.8.2 for more information.
    }

  If either operand is a real operand, then the other operand shall be converted
  to an equivalent real value, and the expression shall be interpreted as a
  comparison between real values.

  \textelp{}
\end{lrmquote}

\setcounter{section}{7}

\begin{lrmquote}{11.4.8}{281}

  \section{Bitwise operators}

  \textelp{}

  For the binary bitwise operators, if one or both operands are unsigned, the
  result is unsigned.
    {
      \del{}
      If the operands are of unequal bit lengths, the smaller
      operand shall be zero-extended to the size of the larger operand.
    }

  If both operands are signed, the result is signed.
    {
      \del{}
      If the operands are of
      unequal bit lengths, the smaller operand shall be sign-extended to the size of
      the larger operand. See 11.8.2 for more information.
    }

  For the unary bitwise negation operator, if the operand is unsigned, the result
  is unsigned. If the operand is signed, the result is signed.

  \textelp{}
\end{lrmquote}

\renewcommand{\thesection}{11.6.\arabic{section}}
\setcounter{section}{0}

\begin{lrmquote}{11.6.1}{299}
  \section{Rules for expression bit lengths}
  \label{expression-bit-widths}

  {
    \del{}

    The rules governing the expression bit lengths have been formulated so that most
    practical situations have a natural solution.

    The number of bits of an expression (known as the \emph{size} of the
    expression) shall be determined by the operands involved in the expression and
    the context in which the expression is given.

    A \emph{self-determined expression} is one where the bit length of the expression is
    solely determined by the expression itselfâ€”for example, an expression
    representing a delay value.

    A \emph{context-determined expression} is one where the bit length of the expression is
    determined by the bit length of the expression and by the fact that it is part
    of another expression. For example, the bit size of the right-hand expression of
    an assignment depends on itself and the size of the left-hand side.

    Table~11-21 shows how the form of an expression shall determine the bit lengths
    of the results of the expression. In Table~11-21, \texttt{i}, \texttt{j}, and
    \texttt{k} represent expressions of an operand, and \texttt{L(i)} represents the
    bit length of the operand represented by \texttt{i}.

    \begin{center}
      \textbf{Table 11-21---Bit lengths resulting from self-determined expressions}
      \begin{longtable}{|p{0.35\linewidth}|C{0.25\linewidth}|C{0.3\linewidth}|}
        \hline
        \centering \textbf{Expression}
         & \textbf{Bit length}
         & \textbf{Comments}
        \\
        \hline
        Unsized constant number
         & At least 32 bits
         &
        \\
        \hline
        Sized constant number
         & As given
         &
        \\
        \hline
        \verb|i op j|, where op is:

        \binOp{}
         & $\max\left(\Size(i), \Size(j)\right)$
         &
        \\
        \hline
        \verb|op i|, where op is:

        \unOp{}
         & $\Size(i)$
         &
        \\
        \hline
        \verb|i op j|, where op is:

        \compOp{}
         & 1 bit
         & Operands are sized to $\max\left(\Size(i), \Size(j)\right)$ \\
        \hline
        \verb|i op j|, where op is:

        \logicOp{}
         & 1 bit
         & All operands are self-determined
        \\
        \hline
        \verb|op i|, where op is:

        \redOp{}
         & 1 bit
         & All operands are self-determined
        \\
        \hline
        \verb|i op j|, where op is:

        \shiftOp{}
         & $\Size(i)$
         & j is self-determined
        \\
        \hline
        \verb|i ? j : k|
         & $\max\left(\Size(j), \Size(k)\right)$
         & i is self-determined
        \\
        \hline
        \verb|{i, ..., j}|
         & $\Size(i) + \dots + \Size(j)$
         & All operands are self-determined
        \\
        \hline
        \verb|{i {j, ..., k}}|
         & $i\times\left(\Size(i) + \dots + \Size(j)\right)$
         & All operands are self-determined
        \\
        \hline
      \end{longtable}
    \end{center}

    Multiplication may be performed without losing any overflow bits by assigning
    the result to something wide enough to hold it.
  }

\end{lrmquote}
{
\add{}
The number of bits of any expression is determined by the operands and the
context in which it occurs. Casting can be used to set the target width of an
intermediate value (see 6.24).

Controlling the number of bits that are used in expression evaluations is
important if consistent results are to be achieved. The following typing system
provides precise rules for determining expression bit widths in all situations.

The bit width of expressions is defined using the fundamental concepts:

\begin{description}
  \item[Self-determined width]
    The \sds{} is the intrinsic width of an expression: i.e.~it is
    solely based on the expression's internal structure and operands.

  \item[Resizing]
    Expressions \mbr{} to bit-widths greater than or equal to their \sds{}. This
    operation may change the width of the internal expression.
\end{description}
}

\begin{lrmquote}{11.6.2}{300}
  \section{Example of expression bit-length problem}
  \textelp{}
\end{lrmquote}

{
\add{}
\section{Expression categories for resizing}%

SystemVerilog expressions shall be categorized into two types based on their
resizing behavior:

\subsection{Atomically resizable expressions}%

Atomically resizable expressions \mbr{} without affecting their
internal operand width. The following expressions are atomically resizable:

\begin{itemize}
  \item Operands as defined in 11.2 (nets, variables, literals, function
    calls, etc.)
  \item Comparison expressions: \compOp{}
  \item Logical expressions: \logicOp{}
  \item Reduction expressions: \redOp{}
  \item Assignment expressions: \texttt{=}
  \item Concatenation expressions: \texttt{\string{\dots\string}}
  \item Replication expressions: \texttt{\string{.\string{\dots\string}\string}}
  \item Set membership expressions: \texttt{inside}
\end{itemize}

When an atomically resizable expression is resized to a
target width, only the expression's result shall be extended --- its operands
shall remain unmodified.

\begin{typingrule}{Atomic-Resize}
  If $e$ has a \sds{} of $t$ and $n$ is larger than $t$
  and $e$ is atomically resizable, then $e$ \mbr{} to $n$.
\end{typingrule}

\subsection{Non-atomically resizable expressions}%

Non-atomically resizable expressions propagate resizing to their operands when
a target width is specified. These expressions require their operands to be
adjusted to specific widths based on the resizing rules. The following expression
are not atomically resizable:

\begin{itemize}
  \item Binary and bitwise expression: \binOp{}
  \item Unary arithmetic, bitwise, increment and decrement expressions:
    \unOp{}
  \item Shift and power expression: \shiftOp{}
  \item Conditional expression: \texttt{?:}
\end{itemize}

Binary arithmetic and bitwise expressions propagate the target width to both
operands:

\begin{typingrule}{Binary-Resize}
  If $a$ \mbr{} to $n$ and $b$ \mbr{} to $n$, then $a \oplus b$ \mbr{} to $n$.
\end{typingrule}

Unary arithmetic, unary bitwise negation and unary increment and decrement
expressions propagate the target width to their single operand:

\begin{typingrule}{Unary-Resize}
  If $e$ \mbr{} to $n$, then $\oplus e$ \mbr{} to $n$.
\end{typingrule}

Shift and power expressions propagate the target width only to the left operand,
while the right operand remains \emph{self-determined}:

\begin{typingrule}{Shift-Resize}
  If $a$ \mbr{} to $n$ and $b$ has a \sds{} of $t_{b}$, then
  $a \oplus b$ \mbr{} to $n$.
\end{typingrule}

Conditional expressions propagate the target width to both branch expressions,
while the condition remains \emph{self-determined}:

\begin{typingrule}{Conditional-Resize}
  If $c$ has a \sds{} width of $t_{C}$ and $t_{e}$ \mbr{} to $n$ and $f_{e}$
  \mbr{} to $n$, then $c~\texttt{?}~t_{e}~\texttt{:}~f_{e}$ \mbr{} to $n$.
\end{typingrule}

\section{\emph{Self-determined} expression sizing rules}%
\label{self-determined}

The \sds{} of an expression, solely based on its internal
structure and operands, shall be computed according to the following rules:

\subsection{Operands}%

For operands as defined in 11.2, the \sds{} is always
well-defined and determined by their declaration, literal specification, or
result type:

\begin{typingrule}{Operand-Size}
  If $e$ is an operand and $s$ its width, then $e$ shall have a \sds{} of $s$.
\end{typingrule}

Examples:

\begin{itemize}
  \item Sized integer literals: \verb|8'hFF| has a \sds{} of 8,
    \verb|32'd123| has a \sds{} of 32,
  \item Unsized integer literals: \verb|123|, \verb|'hABC| have a
    \sds{} of at least 32 bits,
  \item Parameters, nets, variables and structure fields have their width
    defined by their declaration: \verb|logic [15:0] data| has a
    \sds{} of 16,
  \item Bit-select: \verb|data[5]| has a \sds{} of 1,
  \item Part-select: \verb|data[7:0]| has a \sds{} of 8,
    \verb|data[base +: 4]| has a \sds{} of 4,
  \item Function calls: Have their width defined by their return type --- a
    function returning \verb|logic [31:0]| has a
    \sds{} of 32,
  \item Variadic sized function calls: For functions whose return type depends
    on their arguments, the arguments' widths shall be determined as if
    they were in an assignment context. Once all argument widths are
    determined, the function's result type becomes known and defines the
    \sds{}.
\end{itemize}

\subsection{Binary arithmetic and bitwise expressions}%

For binary arithmetic and bitwise expressions, the \sds{}
is the maximum of the operand widths. The smaller operand is \emph{resized}
to match the larger operand's widths.

\begin{typingrule}{Binary-Left-Width}
  If $a$ has a \sds{} of $t$ and $b$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $t$.
\end{typingrule}

\begin{typingrule}{Binary-Right-Width}
  If $b$ has a \sds{} of $t$ and $a$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $t$.
\end{typingrule}

\subsection{Unary expressions}%

For unary expressions (Unary arithmetic, unary bitwise negation and unary
increment and decrement), the \sds{} is identical to the
operand width.

\begin{typingrule}{Unary-Width}
  If $e$ has a \sds{} of $t$, then $\oplus e$ shall have
  a \sds{} of $t$.
\end{typingrule}

\subsection{Relational and equality expressions}%

For relational and equality expressions, the \sds{} is
always 1 bit. The smaller operand shall be resized to match the larger operand's
width for comparison purposes.

\begin{typingrule}{Relational-Left-Width}
  If $a$ has a \sds{} of $t$ and $b$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $1$.
\end{typingrule}

\begin{typingrule}{Relational-Right-Width}
  If $b$ has a \sds{} of $t$ and $a$ \mbr{}
  to $t$, then $a \oplus b$ shall have a \sds{} of $1$.
\end{typingrule}

\subsection{Logical expressions}%

For binary logical expressions, the \sds{} is always 1 bit.
All operands are \emph{self-determined}.

\begin{typingrule}{Logical-Width}
  If $a$ has a \sds{} of $t_{a}$ and $b$ has a
  \sds{} of $t_{b}$, then $a \oplus b$ shall have a
  \sds{} of 1.
\end{typingrule}

\subsection{Reduction expressions}%

For reduction expressions, including \texttt{!}, the \sds{}
is always 1 bit. The operand is \emph{self-determined}.

\begin{typingrule}{Reduction-Width}
  If $e$ has a \sds{} of $t$, then $\oplus e$ shall have a
  \sds{} of 1.
\end{typingrule}

\subsection{Shift and power expressions}%

For shift and power expressions, the \sds{} is determined
by the left operand. The right operand shall be \emph{self-determined}.

\begin{typingrule}{Shift-Width}
  If $a$ has a \sds{} of $t$ and $b$ has a
  \sds{} of $t_{b}$, then $a \oplus b$ shall have a
  \sds{} of $t$.
\end{typingrule}

\subsection{Assignment expressions}%

For assignment expressions, the \sds{} is determined by the
left-hand side. When the left-hand side has a larger width than the right-hand
side, the right-hand side shall \emph{be resized}. Otherwise, the right-hand
side shall be \emph{self-determined}.

\begin{typingrule}{Assignment-Left-Width}
  If the left-hand side $l$ has a width of $t$ and $e$ \mbr{} to
  $t$, then $l \oplus e$ shall have a \sds{} of $t$.
\end{typingrule}

\begin{typingrule}{Assignment-Right-Width}
  If the left-hand side $l$ has a width of $t$, $e$ has a
  \sds{} of $t_{e}$ and $t$ is smaller than $t_{e}$, then
  $l \oplus e$ shall have a \sds{} of $t$.
\end{typingrule}

\subsection{Conditional expressions}%

For conditional expressions using the \texttt{?:} operator, the
\sds{} is the maximum width of the two branch expressions.
The smaller branch shall be resized to match the larger branch. The condition
shall be \emph{self-determined}.

\begin{typingrule}{Conditional-Left-Width}
  If $c$ has a \sds{} of $t_{c}$, $a$ has a
  \sds{} of $t$, and $b$ \mbr{} to $t$,
  then $c \verb|?| a \verb|:| b$ shall have a \sds{} of
  $t$.
\end{typingrule}

\begin{typingrule}{Conditional-Right-Width}
  If $c$ has a \sds{} of $t_{c}$, $b$ has a
  \sds{} of $t$, and $a$ \mbr{} to $t$,
  then $c \verb|?| a \verb|:| b$ shall have a \sds{} of
  $t$.
\end{typingrule}

\subsection{Concatenation expressions}%

For concatenation expressions, the \sds{} is the sum of the
\emph{self-determined widths} of all operands.

\begin{typingrule}{Concatenation-Width}
  If $e_{1}$ has a \sds{} of $t_{1}$, \ldots, $e_{k}$ has a
  \sds{} of $t_{k}$, and $t$ is the sum of
  $t_{1}, \dots, t_{k}$, then $\verb|{|e_{1}, \dots, e_{k}\verb|}|$ shall have
  a \sds{} of $t$.
\end{typingrule}

\subsection{Replication expressions}%

The \sds{} of a replication is the
\sds{} of the inner concatenation multiplied by the
replication amount.

\begin{typingrule}{Replication-Width}
  If $i$ is the amount of the replication and $e_{in}$ has a
  \sds{} of $t_{in}$, and $t$ is $i \times t_{in}$, then
  $\verb|{| i \verb|{| e_{in}\verb|}}|$ shall have a
  \sds{} of $t$.
\end{typingrule}
}

\begin{lrmquote}{11.6.3}{301}

  \section{Example of self-determined expressions}
  \label{examples}

  {
    \del{}
    \begin{verbatim}
logic [3:0] a;
logic [5:0] b;
logic [15:0] c;
initial begin
   a = 4'hF;
   b = 6'hA;
   $display("a*b=%h", a*b);   // expression size is self-determined
   c = {a**b};                // expression a**b is self-determined
                              // due to concatenation operator {}
   $display("a**b=%h", c);
   c = a**b;                  // expression size is determined by c
   $display("c=%h", c);
end
\end{verbatim}

    Simulator output for this example:
    \begin{verbatim}
a*b=16   // 'h96 was truncated to 'h16 since expression size is 6
a**b=1   // expression size is 4 bits (size of a)
c=ac61   // expression size is 16 bits (size of c)
\end{verbatim}

  }
\end{lrmquote}

{
\add{}
This section illustrates the application of sizing and type-derivation
rules as defined in this specification. The examples are derived from
the following declarations:
{
\color{black}
\begin{minted}{verilog}
logic [7:0]  var8;     // 8-bit variable
logic [31:0] var32;    // 32-bit variable
logic [15:0] var16;    // 16-bit variable
logic        cond;     // condition signal
logic [63:0] result;   // 64-bit result variable
\end{minted}
}

\subsection{Basic Expression Sizing}

This subsection demonstrates basic operand and binary expression
sizing behavior.

Given the above declarations, the expression \sv{var8} has \sds{} 8.
By application of rule \textbf{Operand-Width}:
\begin{itemize}
  \item \sv{var8} is an operand with width 8, as declared
    in \sv{logic [7:0] var8}.
\end{itemize}

The expression \sv{var16[15:8] + 4'b1001} has \sds{} 8.
By application of rule \textbf{Binary-Left-Width}:
\begin{itemize}
  \item \sv{var16[15:8]} has \sds{} 8 (by
    \textbf{Operand-Width}, part-select of 8 bits).
  \item \sv{4'b1001} \mbr{} to 8 by rule \textbf{Resize}:
    \begin{itemize}
      \item \sv{4'b1001} has \sds{} 4 (by
        \textbf{Operand-Width}, sized literal).
      \item 8 is greater than 4.
      \item \sv{4'b1001} is atomically resizable.
    \end{itemize}
\end{itemize}

Application of rule \textbf{Binary-Right-Width} to this expression
would not succeed, as it would require resizing \sv{var16[15:8]} to
4 bits.

The expression \sv{var16[5] + 8'hFF} has \sds{} 8. By rule
\textbf{Binary-Right-Width}:
\begin{itemize}
  \item \sv{8'hFF} has \sds{} 8 (by \textbf{Operand-Width},
    sized literal).
  \item \sv{var16[5]} \mbr{} to 8 by rule \textbf{Resize}:
    \begin{itemize}
      \item \sv{var16[5]} has \sds{} 1 (by
        \textbf{Operand-Width}, bit-select).
      \item 8 is greater than 1.
      \item \sv{var16[5]} is atomically resizable.
    \end{itemize}
\end{itemize}

\subsection{Relational Expression Example}

This subsection illustrates the determination of sizing for relational
expressions.

For the expression \sv{var16 > 16'd100}, the resulting \sds{} is 1.
By rule \textbf{Relational-Left-Width}:
\begin{itemize}
  \item \sv{var16} has \sds{} 16 (by \textbf{Operand-Width},
    declaration \sv{logic [15:0] var16}).
  \item \sv{16'd100} \mbr{} to 16 (already 16 bits):
    \begin{itemize}
      \item \sv{16'd100} has \sds{} 16 (by
        \textbf{Operand-Width}, sized literal).
    \end{itemize}
\end{itemize}

\subsection{Reduction Expression Example}

This subsection demonstrates sizing for reduction operations.

For the expression \sv{&var16[7:0]}, the resulting \sds{} is 1.
By rule \textbf{Reduction-Width}:
\begin{itemize}
  \item \sv{var16[7:0]} has \sds{} 8 (by
    \textbf{Operand-Width}, part-select of 8 bits).
\end{itemize}

\subsection{Replication Expression Example}

This subsection illustrates the effect of replication on expression
width.

For the expression \sv{{4{var8}}}, the resulting \sds{} is 32.
By rule \textbf{Replication-Width}:
\begin{itemize}
  \item The replication count $i$ is 4.
  \item \sv{var8} has \sds{} 8 (by \textbf{Operand-Width},
    declaration \sv{logic [7:0] var8}).
  \item The resulting width is $4 \times 8 = 32$.
\end{itemize}

\subsection{Complex Replication with Concatenation}

This subsection shows replication applied to a concatenated operand.

For the expression \sv{{2{var16[7:0], 4'hF}}}, the resulting
\sds{} is 24. By rule \textbf{Replication-Width}:
\begin{itemize}
  \item The replication count $i$ is 2.
  \item The inner concatenation \sv{{var16[7:0], 4'hF}} has
    \sds{} 12 by rule \textbf{Concatenation-Width}:
    \begin{itemize}
      \item \sv{var16[7:0]} has \sds{} 8 (by
        \textbf{Operand-Width}, part-select).
      \item \sv{4'hF} has \sds{} 4 (by
        \textbf{Operand-Width}, sized literal).
      \item Sum is $8 + 4 = 12$.
    \end{itemize}
  \item The resulting width is $2 \times 12 = 24$.
\end{itemize}

\subsection{Assignment with Target Width Extension}

This subsection illustrates extension of a right-hand operand to
match the assignment target.

For the expression \sv{var32 = var16[7:0] + 1}, the resulting
\sds{} is 32. By rule \textbf{Assignment-Left-Width}:
\begin{itemize}
  \item Left-hand side \sv{var32} has width 32
    (by declaration \sv{logic [31:0] var32}).
  \item Right-hand side \sv{var16[7:0] + 1} \mbr{} to 32
    by rule \textbf{Binary-Resize}:
    \begin{itemize}
      \item \sv{var16[7:0]} \mbr{} to 32 by rule \textbf{Resize}:
        \begin{itemize}
          \item \sv{var16[7:0]} has \sds{} 8 (by
            \textbf{Operand-Width}, part-select).
          \item 32 is greater than 8.
          \item \sv{var16[7:0]} is atomically resizable.
        \end{itemize}
      \item \sv{1} \mbr{} to 32 (unsized literals have
        at least 32 bits).
    \end{itemize}
\end{itemize}

\subsection{Assignment with Result Truncation}

This subsection shows truncation of the right-hand result to match
the left-hand target width.

For the expression \sv{var8 = var32 + var16}, the resulting
\sds{} is 8. By rule \textbf{Assignment-Right-Width}:
\begin{itemize}
  \item Left-hand side \sv{var8} has width 8 (by
    declaration \sv{logic [7:0] var8}).
  \item Right-hand side \sv{var32 + var16} has \sds{} 32
    (by \textbf{Binary-Left-Width}):
    \begin{itemize}
      \item \sv{var32} has \sds{} 32 (by
        \textbf{Operand-Width}, declaration
        \sv{logic [31:0] var32}).
      \item \sv{var16} \mbr{} to 32 by rule \textbf{Resize}:
        \begin{itemize}
          \item \sv{var16} has \sds{} 16 (by
            \textbf{Operand-Width}, declaration
            \sv{logic [15:0] var16}).
          \item 32 is greater than 16.
          \item \sv{var16} is atomically resizable.
        \end{itemize}
    \end{itemize}
  \item 8 is smaller than 32.
\end{itemize}

\subsection{Conditional Expression with True Branch Determining Size}

This subsection demonstrates conditional sizing where the true
branch determines the resulting width.

For the expression \sv{cond ? var32 : var8}, the resulting \sds{} is
32. By rule \textbf{Conditional-Left-Width}:
\begin{itemize}
  \item Condition \sv{cond} has \sds{} 1 (by
    \textbf{Operand-Width}, declaration \sv{logic cond}).
  \item True branch \sv{var32} has \sds{} 32 (by
    \textbf{Operand-Width}, declaration \sv{logic [31:0] var32}).
  \item False branch \sv{var8} \mbr{} to 32 by rule \textbf{Resize}:
    \begin{itemize}
      \item \sv{var8} has \sds{} 8 (by
        \textbf{Operand-Width}, declaration \sv{logic [7:0] var8}).
      \item 32 is greater than 8.
      \item \sv{var8} is atomically resizable.
    \end{itemize}
\end{itemize}

\subsection{Conditional Expression with False Branch Determining Size}

This subsection demonstrates conditional sizing where the false
branch determines the resulting width.

For the expression \sv{cond ? var8 : var32}, the resulting \sds{} is
32. By rule \textbf{Conditional-Right-Width}:
\begin{itemize}
  \item Condition \sv{cond} has \sds{} 1 (by
    \textbf{Operand-Width}, declaration \sv{logic cond}).
  \item False branch \sv{var32} has \sds{} 32 (by
    \textbf{Operand-Width}, declaration \sv{logic [31:0] var32}).
  \item True branch \sv{var8} \mbr{} to 32 by rule \textbf{Resize}:
    \begin{itemize}
      \item \sv{var8} has \sds{} 8 (by
        \textbf{Operand-Width}, declaration \sv{logic [7:0] var8}).
      \item 32 is greater than 8.
      \item \sv{var8} is atomically resizable.
    \end{itemize}
\end{itemize}

\subsection{Conditional Expression with Context-Driven Sizing}

This subsection demonstrates conditional sizing determined by the
context of an assignment target.

For the expression \sv{result = cond ? var32[7:0] : var32[15:8]}, the
resulting \sds{} is 64. By rule \textbf{Assignment-Left-Width}:
\begin{itemize}
  \item Left-hand side \sv{result} has width 64 (by
    declaration \sv{logic [63:0] result}).
  \item Right-hand side \sv{cond ? var32[7:0] : var32[15:8]}
    \mbr{} to 64 by rule \textbf{Conditional-Resize}:
    \begin{itemize}
      \item Condition \sv{cond} has \sds{} 1 (by
        \textbf{Operand-Width}, declaration \sv{logic cond}).
      \item True branch \sv{var32[7:0]} \mbr{} to 64 by
        \textbf{Resize}:
        \begin{itemize}
          \item \sv{var32[7:0]} has \sds{} 8 (by
            \textbf{Operand-Width}, part-select).
          \item 64 is greater than 8.
          \item \sv{var32[7:0]} is atomically resizable.
        \end{itemize}
      \item False branch \sv{var32[15:8]} \mbr{} to 64 by
        \textbf{Resize}:
        \begin{itemize}
          \item \sv{var32[15:8]} has \sds{} 8 (by
            \textbf{Operand-Width}, part-select).
          \item 64 is greater than 8.
          \item \sv{var32[15:8]} is atomically resizable.
        \end{itemize}
    \end{itemize}
\end{itemize}
}

\renewcommand{\thesection}{11.\arabic{section}}
\setcounter{section}{6}

\begin{lrmquote}{11.7}{301}
  \section{Signed expressions}
  \textelp{}
\end{lrmquote}

\renewcommand{\thesection}{11.8.\arabic{section}}
\setcounter{section}{1}

\begin{lrmquote}{11.8.2}{302}
  {
    \del{}

    \section{Steps for evaluating an expression}

    The following are the steps for evaluating an expression:
    \begin{itemize}
      \item Determine the expression size based upon the standard rules of
        expression size determination (see 11.6).
      \item Determine the sign of the expression using the rules outlined in
        11.8.1.
      \item Propagate the type and size of the expression (or self-determined
        subexpression) back down to the context-determined operands of the
        expression. In general, any context-determined operand of an operator
        shall be the same type and size as the result of the operator.
        However, there are two exceptions:
        \begin{itemize}
          \item If the result type of the operator is real and if it has a
            context-determined operand that is not real, that operand
            shall be treated as if it were self-determined and then
            converted to real just before the operator is applied.
          \item The relational and equality operators have operands that are
            neither fully self-determined nor fully context-determined. The
            operands shall affect each other as if they were context-determined
            operands with a result type and size (maximum of the two operand
            sizes) determined from them. However, the actual result type shall
            always be 1 bit unsigned. The type and size of the operand shall be
            independent of the rest of the expression and vice versa.
        \end{itemize}
      \item When propagation reaches a simple operand as defined in 11.5, then
        that operand shall be converted to the propagated type and size. If the
        operand shall be extended, then it shall be sign-extended only if the
        propagated type is signed.
    \end{itemize}
  }
\end{lrmquote}
\begin{lrmquote}{11.8.3}{303}
  {
    \del{}

    \section{Steps for evaluating an assignment}

    The following are the steps for evaluating an assignment:
    \begin{itemize}
      \item Determine the size of the right-hand side by the standard assignment
        size determination rules (see 11.6).
      \item If needed, extend the size of the right-hand side, performing sign
        extension if, and only if, the type of the right-hand side is signed.
    \end{itemize}
  }
\end{lrmquote}
\begin{lrmquote}{11.8.4}{303}
  \section{Handling x and z in signed expressions}

  \textelp{}
\end{lrmquote}


\appendix

{

  \add{}
  \section{Technical Appendix: Algorithm Overview}
  \label{algorithm-overview}

  This appendix presents an algorithm to compute the width of all sub-expressions
  of a SystemVerilog expression. The algorithm operates in two phases:

  First, the \sds{} of the expression is computed using the algorithm
  \ref{alg:determine}. This algorithm traverses the expression
  tree bottom-up to determine the natural width of each expression based solely on
  its internal structure and operands.

  Second, the expression and all its sub-expressions are resized to the target
  width using the algorithm \ref{alg:propagate}. During this
  propagation phase, all self-determined sub-expressions are resized to their
  \sds{}, while the other sub-expressions inherit their width from the surrounding
  context.

  Assuming that call to the \textsc{Determine} function are cached, the algorithm
  runs in linear time with respect to the number of operations in
  the SystemVerilog expression. The reasoning implemented in this algorithm
  follows the typing rules explained in the previous
  \autoref{expression-bit-widths}.


  \newcommand\Determine[1]{\textsc{determine}(#1)}
  \newcommand\Propagate[1]{\textsc{propagate}(#1)}

  \begin{algorithm}
    \caption{Determine}
    \label{alg:determine}

    \SetKwData{Expr}{expr}
    \SetKwData{Lhs}{lhs}
    \SetKwData{LhsW}{lhs\textsubscript{w}}
    \SetKwData{Rhs}{rhs}
    \SetKwData{RhsW}{rhs\textsubscript{w}}
    \SetKwData{Arg}{arg}
    \SetKwData{ArgW}{arg\textsubscript{w}}
    \SetKwData{Lval}{lval}
    \SetKwData{LvalW}{lval\textsubscript{w}}
    \SetKwData{Cond}{cond}
    \SetKwData{CondW}{cond\textsubscript{w}}
    \SetKwData{ExprA}{expr\textsubscript{1}}
    \SetKwData{ExprN}{expr\textsubscript{N}}
    \SetKwData{ExprI}{expr\textsubscript{i}}
    \SetKwData{WidthI}{width\textsubscript{i}}

    \DontPrintSemicolon
    \SetAlgoVlined
    \LinesNumbered

    \KwIn{A SystemVerilog expression \Expr}
    \KwOut{The self-determined width of \Expr}
    \BlankLine
    \Switch{\Expr}{
      \Case{\Expr is an operand}{
        \Return{$\Gamma\left(\Expr\right)$}\;
      }
      \Case(\com{$\oplus$ can be \binOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
        $\LhsW \leftarrow \Determine{\Lhs}$\;
        $\RhsW \leftarrow \Determine{\Rhs}$\;
        \Return{$\max\big(\LhsW, \RhsW\big)$}\;
      }
      \Case(\com{$\oplus$ can be \unOp{}}){\Expr is $\oplus\Arg$}{
        $\ArgW \leftarrow \Determine{\Arg}$\;
        \Return{\ArgW}\;
      }
      \Case(\com{$\oplus$ can be \compOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
        \Return{$1$}\;
      }
      \Case(\com{$\oplus$ can be \logicOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
        \Return{$1$}\;
      }
      \Case(\com{$\oplus$ can be \redOp{}}){\Expr is $\oplus\Arg$}{
        \Return{$1$}\;
      }
      \Case(\com{$\oplus$ can be \shiftOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
        $\LhsW \leftarrow \Determine{\Lhs}$\;
        \Return{\LhsW}\;
      }
      \Case{\Expr is $\Lval\kw{~=~}\Rhs$}{
        $\LvalW \leftarrow \phi(\Lval)$\;
        \Return{\LvalW}\;
      }
      \Case{\Expr is $\Cond\kw{~?~}\Lhs\kw{~:~}\Rhs$}{
        $\LhsW \leftarrow \Determine{\Lhs}$\;
        $\RhsW \leftarrow \Determine{\Rhs}$\;
        \Return{$\max\left(\LhsW,\RhsW\right)$}\;
      }
      \Case{\Expr is $\kw{\{}\ExprA,\kw{~\dots~},\ExprN\kw{\}}$}{
        \For{$i \in \{1, \dots, N\}$}{
          $\WidthI \leftarrow \Determine{\ExprI}$\;
        }
        \Return{$\sum_{i=0}^{N}\WidthI$}\;
      }
      \Case{\Expr is $\kw{\{}n~\Arg\kw{\}}$}{
        $\ArgW \leftarrow \Determine{\Arg}$\;
        \Return{$n\times\ArgW$}\;
      }
    }
  \end{algorithm}

  \begin{algorithm}
    \caption{Propagate}
    \label{alg:propagate}

    \SetKwData{Expr}{expr}
    \SetKwData{TargetW}{targetWidth}
    \SetKwData{Lhs}{lhs}
    \SetKwData{LhsW}{lhs\textsubscript{w}}
    \SetKwData{Rhs}{rhs}
    \SetKwData{RhsW}{rhs\textsubscript{w}}
    \SetKwData{Arg}{arg}
    \SetKwData{ArgW}{arg\textsubscript{w}}
    \SetKwData{Lval}{lval}
    \SetKwData{LvalW}{lval\textsubscript{w}}
    \SetKwData{Cond}{cond}
    \SetKwData{CondW}{cond\textsubscript{w}}
    \SetKwData{ExprA}{expr\textsubscript{1}}
    \SetKwData{ExprN}{expr\textsubscript{N}}
    \SetKwData{ExprI}{expr\textsubscript{i}}
    \SetKwData{WidthI}{width\textsubscript{i}}

    \DontPrintSemicolon
    \SetAlgoVlined
    \LinesNumbered

    \KwIn{A SystemVerilog expression \Expr, A \TargetW to resize \Expr to.}
    \KwResult{All sub-expressions of \Expr are annotated with their final width}
    \Switch{\Expr}{
      \Case{\Expr is an operand}{
        Annotate \Expr with \TargetW\;
      }
      \Case(\com{$\oplus$ can be \binOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
        \Propagate{\Lhs, \TargetW}\;
        \Propagate{\Rhs, \TargetW}\;
        Annotate \Expr with \TargetW\;
      }
      \Case(\com{$\oplus$ can be \unOp{}}){\Expr is $\oplus\Arg$}{
        \Propagate{\Arg, \TargetW}\;
        Annotate \Expr with \TargetW\;
      }
      \Case(\com{$\oplus$ can be \compOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
        $\ArgW \leftarrow \max\left(\Determine{\Lhs}, \Determine{\Rhs}\right)$\;
        \Propagate{\Lhs, \ArgW}\;
        \Propagate{\Rhs, \ArgW}\;
        Annotate \Expr with \TargetW\;
      }
      \Case(\com{$\oplus$ can be \logicOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
        \Propagate{\Lhs, \Determine{\Lhs}}\;
        \Propagate{\Rhs, \Determine{\Rhs}}\;
        Annotate \Expr with \TargetW\;
      }
      \Case(\com{$\oplus$ can be \redOp{}}){\Expr is $\oplus\Arg$}{
        \Propagate{\Arg, \Determine{\Arg}}\;
        Annotate \Expr with \TargetW\;
      }
      \Case(\com{$\oplus$ can be \shiftOp{}}){\Expr is $\Lhs\oplus\Rhs$}{
        \Propagate{\Lhs, \TargetW}\;
        \Propagate{\Rhs, \Determine{\Rhs}}\;
        Annotate \Expr with \TargetW\;
      }
      \Case{\Expr is $\Lval\kw{~=~}\Rhs$}{
        \Propagate{\Rhs, $\max\left(\phi(\Lval), \Determine{\Rhs}\right)$}\;
        Annotate \Expr with \TargetW\;
      }
      \Case{\Expr is $\Cond\kw{~?~}\Lhs\kw{~:~}\Rhs$}{
        \Propagate{\Cond, \Determine{\Cond}}\;
        \Propagate{\Lhs, \TargetW}\;
        \Propagate{\Rhs, \TargetW}\;
        Annotate \Expr with \TargetW\;
      }
      \Case{\Expr is $\kw{\{}\ExprA,\kw{~\dots~},\ExprN\kw{\}}$}{
        \For{$i \in \{1, \dots, N\}$}{
          \Propagate{\ExprI, \Determine{\ExprI}}\;
        }
        Annotate \Expr with \TargetW\;
      }
      \Case{\Expr is $\kw{\{}n~\Arg\kw{\}}$}{
        \Propagate{\Arg, \Determine{\Arg}}\;
        Annotate \Expr with \TargetW\;
      }
    }
  \end{algorithm}
}

\bibliographystyle{splncs04}
\bibliography{refs}

\end{document}
